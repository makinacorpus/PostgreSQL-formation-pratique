<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Formation Pratique PostgreSQL - partie 4 - Administration</title>
    <!-- Styles -->
    <link rel="stylesheet" href="assets/makina/css/pygments/colorful.css">
    <link rel="stylesheet" href="assets/makina/css/pygments/monokai.css">
    <link rel="stylesheet" media="print" href="assets/makina/css/print.css">
    <link rel="stylesheet" media="screen, projection" href="assets/makina/css/screen.css">
    
    <!-- /Styles -->
    <!-- Javascripts -->
    <script type="text/javascript" src="assets/makina/js/slides.js"></script>
    
    <!-- /Javascripts -->
</head>
<body>
  <div id="blank"></div>
  <div class="presentation">
    <div id="time">
      <span id="hours">00</span>:<span id="minutes">00</span>:<span id="seconds">00</span>
    </div>            
    <div id="current_presenter_notes">
      <div id="presenter_note"></div>
    </div>
    <div class="slides">
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h1>Formation Pratique PostgreSQL - partie 4 - Administration</h1>
              
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            
            <img src="assets/makina/logo.png" class="logo" alt="Makina Corpus"/>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              1/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide alternate">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>copyright (c) 2012-2017 : <a href="http://www.makina-corpus.com">Makina Corpus</a></p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              2/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide title1 title1-3">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h1>20. Administration PostgreSQL</h1>
              
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              3/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide title2">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h2>20.1. Pré-requis</h2>
              
              
                <p><small>Puis-je commencer ici?</small></p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              4/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Les chapitres précédents contenaient des informations utiles aux administrateurs.</p>
<p>Ainsi on n'oubliera pas de consulter dans les chapitres précédents:</p>
<ul>
<li>la gestion du <strong>pg_hba.conf</strong> (politique d'accès)</li>
<li>la gestion des <strong>rôles</strong> et des <strong>droits</strong></li>
<li>les backups en dumps <strong>SQL</strong> et <strong>COMPRESS</strong> ainsi que leurs <strong>restaurations</strong></li>
<li><strong>l'indexation</strong></li>
</ul>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              5/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h2>20.2. 32bits vs 64bits</h2>
              
              
                <p>PostgreSQL existe en version 32 ou 64 bits.</p>
<p>Vous pouvez très bien installer une version 32bits sur un OS 64 bits.</p>
<p>Les principaux gains d'une version 64 bits sont:</p>
<ul>
<li>une meilleure gestion des types longs, qui peuvent être utilisés dans des
 registres au lieu de passer par des pointeurs (entiers longs, types date)</li>
<li>la possibilité d'utiliser plus de 2Go pour le paramètre shared_buffers dont
 on verra qu'il s'agit d'un des paramètres très important pour les performances,
 surtout avant la version 9.5.</li>
</ul>
<p>Mais des coûts supplémentaires apparaissent aussi en parallèle sur tous les types
de base (la taille d'un pointeur en RAM augmente).</p>
<p><strong>Sur un Linux 64 bits on devrait toujours installer une version 64bits</strong>.</p>
<p>Sur un serveur Windows la version 64bits est beaucoup moins intéressante car les
 serveurs Windows supportent assez mal une valeur supérieure à <strong>500Mo</strong> pour le
 paramètre <code>shared_buffers</code> (on perd donc le principal gain).</p>
<p>Certains utilisateurs ont rapporté des installations sur Windows avec des très
fortes valeures de <code>work_mem</code>, pour lesquelles une version 64bits était plus performante. Mais comme nous le verrons en étudiant ces deux paramètres
(<code>shared_buffers</code> et <code>work_mem</code>) il s'agit là d'installations atypiques.</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              6/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h2>20.3. Analysez l'usage de la base</h2>
              
              
                <p>Les applications qui utilisent la base peuvent avoir des formes et des usages
divers. On identifie par exemple certaines grandes familles ainsi:</p>
<ul>
<li><strong>Type Web</strong> : Taille des données tenant en RAM, beaucoup de requêtes simples,
 beaucoup de lectures.</li>
<li><strong>OLTP (Online Transaction Processing)</strong> :  Taille des données très importante
  (supérieure à la RAM), un nombre important d'opérations d'écritures (plus de
  20% des requêtes). Des transactions importantes (beaucoup d'écritures au sein
  d'une même transaction)</li>
<li><strong>Data Warehouse, Business Intelligence</strong> : taille des données très importante,
 requêtes d'agrégation complexes (BI), requêtes d'import/export de grandes
 quantités de données</li>
</ul>
<p>Les différents conseils sur les performances attendues des données dépendront du
profil de la base. Si vos usages sont très différents et que vous hébergez
plusieurs bases peut-être devrez-vous songer à utiliser différents serveurs de
base de données.</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              7/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h2>20.4. Autovacuum, vacuum et analyze</h2>
              
              
                <ul>
<li><a href="http://docs.postgresql.fr/9.5/maintenance.html">http://docs.postgresql.fr/9.5/maintenance.html</a></li>
<li><a href="http://docs.postgresql.fr/9.5/runtime-config-autovacuum.html">http://docs.postgresql.fr/9.5/runtime-config-autovacuum.html</a></li>
</ul>
<p>La page de documentation de PostgreSQl sur les opérations de maintenance est
assez complète.</p>
<p>Parmi les choses importantes il faut identifier <strong>le service autovacuum.</strong></p>
<p>Il s'agit d'un des processus fils de PostgreSQL dont le travail est de détecter
les maintenance à effectuer et <strong>de les faire au fil de l'eau</strong>.</p>
<p>Parmi toutes les tâches de maintenance les plus importantes sont donc les
<strong>VACUUM</strong>. Le but du vacuum est <strong>triple</strong>:</p>
<ul>
<li><strong>optimiser l'espace disque</strong> occupé par la base, le fichier physique stocke
  plusieurs versions des lignes, ce qui permet d'assurer le MVCC dans les
  transactions. Lors des vacuums les lignes qui ne sont plus valides seront
  supprimées.</li>
<li><strong>Mettre à jour les statistiques</strong> sur le nombre de lignes des tables ou les
  cardinalités des index. Ceci afin d'optimiser les choix fait par l'analyseur
  de requête (vaut-il mieux un <em>seqscan</em> ou utiliser un <em>index</em> ?)</li>
<li>A <strong>long terme</strong> éviter d'avoir un problème de <strong>cycle d'identifiant de
  transaction</strong> (qui n'est pas un nombre infini)</li>
</ul>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              8/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>vacuum full</h3>
              
              
                <p>Il y a une forme extrême du <strong>VACUUM</strong> qui est <strong>VACUUM FULL</strong>.</p>
<p>Cette commande SQL provoque une sorte de réécriture complète de la table, une
réorganisation de toutes ces lignes. <strong>C'est une opération longue et bloquante.</strong></p>
<p>Depuis la version 9.0 de PostgreSQL cette opération est plus rapide que sur les
 versions précédentes mais elle impose de <strong>disposer de deux fois la taille
 physique de la table</strong>, Si vous avez une table 2Go sur laquelle vous effectuez
 un <code>VACUUM FULL</code> une nouvelle table sera créé, il faut donc environ 2Go
 d'espace disque disponible. Cette opération pose un <strong>LOCK exclusif</strong> sur la
 table, elle est inaccessible pour PostgreSQL.</p>
<p>Heureusement il n'est pas nécessaire à priori d'effectuer des <code>VACUUM FULL</code>.</p>
<p>Les opérations VACUUM standard suffisent à obtenir des maintenances efficaces et
ne sont pas bloquantes, ni en lecture ni en écriture (le DDL est bloqué par
contre).</p>
<p>On n'utilisera le VACUUM FULL que sur une table qui <strong>après des imports/exports
massifs</strong> occupe visiblement une place trop importante. Sur un fonctionnement
normal de la base <strong>l'exécution régulière de VACUUM classiques</strong> permet de ne
pas avoir de gaspillage de place.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              9/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>autovacuum</h3>
              
              
                <p>Le but d'autovacuumm est donc de tourner suffisamment souvent pour maintenir la
taille physique des tables et pour garantir que le planificateur de requête
dispose d'informations à jour.</p>
<p>Le démon autovacuum dispose d'indicateurs pour ces deux fonctions qui vont lui permettre de décider du moment ou il devra agir.</p>
<p>Parallèlement il ne faut pas que les vacuum se lancent trop souvent car s'ils ne
sont pas bloquants ils sont cependant consommateurs en ressource serveur.</p>
<p>Il y a des paramètres généraux qui s'appliquent à toutes les tables mais on peut changer ce paramétrage pour une table (disponible dans les propriétés de la
table sur pgadmin):</p>
<pre><code># suspendre l'autovacuum pour une table
ALTER TABLE mytable SET autovacuum_enabled = false;
# le rétablir
ALTER TABLE mytable SET autovacuum_enabled = true;
# Mettre des réglages particuliers pour une table
ALTER TABLE mytable SET (
  autovacuum_vacuum_threshold = 25,
  autovacuum_analyze_threshold = 15,
  autovacuum_vacuum_scale_factor = 0.1,
  autovacuum_analyze_scale_factor = 0.001,
  autovacuum_vacuum_cost_delay = 10,
  autovacuum_vacuum_cost_limit = 100
);
</code></pre>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              10/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>La documentation nous donne ces deux formules:</p>
<pre><code>limite du vacuum = limite de base du vacuum
                   + facteur d'échelle du vacuum * nombre de lignes
limite du analyze = limite de base du analyze
                    + facteur d'échelle du analyze * nombre de lignes
</code></pre>
<p>Si on mets les vrais noms de variables et des parenthèses on obtient:</p>
<pre><code>limite du vacuum = autovacuum_vacuum_threshold
                   + (autovacuum_vacuum_scale_factor *nb lignes)
limite du analyze = autovacuum_analyze_thresold
                   + (autovacuum_analyze_scale_factor *nb lignes)
</code></pre>
<ul>
<li><strong>autovacuum_vacuum_threshold</strong> : Après que ce nombre de lignes mortes dans la
 table (dues à des  delete ou update) soit atteint un vacuum sera lancé afin de
 récupérer de l'espace disque.</li>
<li><strong>autovacuum_analyze_threshold</strong> : Après avoir atteint, en gros, ce nombre
 d'insert ou update ou delete un vacuum analyze sera lancé afin de mettre à jour
 les statistiques utilisées par l'analyseur de requêtes.</li>
</ul>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              11/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Les <code>*_scale_factor</code> sont des pourcentages appliqués à la taille de la table et
vont ajouter des valeurs au « thresold » (seuil) original. Donc une grosse table
(2 millions de lignes) avec un scale factor de 0.1 (10%) va ajouter 200 000 au
seuil:</p>
<pre><code>limite du vacuum = 50 + (0.1 * 2 000 000) = 50 + 200 000 = 200 050
</code></pre>
<p>Les paramètres <strong>cost</strong> et <strong>delay</strong> servent à éviter de trop impacter le
 fonctionnement normal de la base en forçant des suspensions/reprises des tâches
d'autovacuum en cours de traitement quand celle-ci atteignent les coûts indiqués.</p>
<p>Ces réglages ne sont à modifier que si vous observez des ralentissements
généraux dus aux vacuums de certains tables importantes.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              12/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>vacuumdb</h3>
              
              
                <p>Un utilitaire <code>vacuumdb</code> existe, avec un ensemble d'options disponibles, dont
une option <code>-j</code> qui permet de paralléliser les traitements de maintenance
(depuis la version 9.4).</p>
<p>Par exemple cette commande, lancée par l'utilisateur postgres:</p>
<pre><code>vacuumdb -j4 formation
</code></pre>
<p>Va permettre de lancer des vacuum en utilisant 4 process parallèles.</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              13/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p><strong>Comment savoir si on doit changer les réglages par défaut d'une table ?</strong></p>
<p>En utilisant les outils de monitoring qui indiqueront les tables qui n'ont pas
subit de vacuum depuis très longtemps et en tracant les explain avec les requêtes
lentes, afin d'y repérer des mauvaises estimations de coûts par l'analyseur de
requête.</p>
<p><strong>Quelques points pour vous aider à trouver les bon réglages :</strong></p>
<ul>
<li>les valeurs indiquées pour <strong>analyze</strong> devraient être supérieures à celles de
<strong>vacuum</strong> car elles comptent aussi les insertions (si vous avez des insertions
 sur cette table)</li>
<li>Pour une table <strong>statique</strong> (données de paramétrage par exemple), où les
 données bougent très rarement, ne vous occupez pas des problèmes de vacuum</li>
<li>Une table qui ne subit <strong>que des insertions</strong> n'aura <strong>jamais de vacuum</strong>
 (mais n'a pas besoin de vacuum, si vous avez uniquement des insertions et un fillfactor à 100 la table ne va pas gaspiller d'espace disque)</li>
</ul>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              14/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <div class="warning"><p>
Sur une table qui ne subit que des insertions ne vous occupez que des paramètres
analyze.
</p></div>

<div class="warning"><p>
faire tourner de petits vacuum fréquemment est moins coûteux que de faire tourner
un gros vacuum
</p></div>

<div class="warning"><p>
Pour les <b>grosses tables</b> (en nombre de lignes) qui subissent un <b>grand nombre d'insertions</b> vous aurez besoin de faire tourner <b>analyze</b> fréquemment,
 <b>réduisez le autovacuum_analyze_scale_factor</b>
</p></div>

<div class="warning"><p>
Pour les <b>grosses tables</b> (en nombre de lignes) avec beaucoup de
 <b>mouvements (delete, update, insert)</b> vous devriez <b>réduire le
  autovacuum_vacuum_scale_factor</b> pour avoir plus souvent des opérations de
  vacuum. Vous pouvez aussi décider de monter le <b>autovacuum_vacuum_thresold</b>
  à un chiffre élevé (comme 1000 ou 5000) et mettre <b>0 au  autovacuum_vacuum_scale_factor</b>.
</p></div>


              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              15/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <div class="warning"><p>
Les réglages par défaut seront très bien (au sens ou vous n'avez pas besoin de
les modifier) si vous ne subissez pas de ralentissements sur vos requêtes et si
votre espace disque occupé est raisonnable
</p></div>

<div class="warning"><p>
Sur une <b>grosse table</b> avec <b>beaucoup de mises à jour</b> (chose assez
peu fréquente en fait) un moyen simple d'obtenir un vacuum plus <b>prévisible</b>
est de <b>diminuer le factor</b> et de mettre dans le <b>thresold une valeure
basse du nombre d'opérations par jour</b>.
</p></div>

<div class="warning"><p>
Pour une table qui reçoit des mises à jour en <b>mode batch</b>, par exemple
elle reçoit <b>10 000</b> nouvelles lignes chaque nuit graĉe à un cron; mettez
le <b>thresold d'analyze à 10000 et le factor à 0</b>, ainsi seul le nombre
d'insertions va déterminer le lancement du vacuum. S'il ne s'agit pas que
d'insertions mais aussi de mises à jour et de suppressions modifiez le thresold
et le factor du vacuum de la même façon.
</p></div>

<div class="warning"><p>
Vous pouvez aussi forcer le lancement de commandes VACCUUM sur les tables
impactées <b>en fin de batch</b>. On doit aussi parfois forcer ces commandes
<b>en cours de batch</b> pour s'assurer que le batch utilisera les bonnes
optimisations de requête.
</p></div>


              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              16/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide title2">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h2>20.5. Paramètres de configuration principaux</h2>
              
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              17/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Les paramètres de postgreSQL se trouvent dans le fichier <code>postgresql.conf</code>.</p>
<p>Ce fichier est disponible dans les répertoires <code>/etc/postgresql/*</code> sur les
 distributions type debian, mais il s'agit en fait, comme le <code>pg_hba.conf</code> que
 nous avons vu dans les parties précédentes, d'un simple raccourci vers le
 répertoire de stockage physique de la base.</p>
<p>La lecture complète de ce fichier et des commentaires qui s'y trouve vous
apportera toujours une base de connaissance utile (les commentaires indiquent
par exemple les paramètres qui nécessitent un redémarrage complet du serveur
pour être pris en compte, dans le cas contraire un simple reload suffira).</p>
<p>Faisons le point sur les principaux paramètres...</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              18/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.5.1. Connexions</h3>
              
              
                <ul>
<li><strong>listen_addresses</strong> : liste des interfaces réseau sur lesquelles le serveur
 est à l'écoute. Par défaut 'localhost' et onc uniquement en local, mettez '*'
 pour utiliser toutes les adresses réseaux du serveur.</li>
<li><strong>port</strong> : le port sur lequel le serveur est en écoute sur les interfaces
  listées dans le paramètre précédent. Modifiez le si plusieurs instances de
  PostgreSQL doivent tourner en parallèle (comme lors d'un upgrade)</li>
<li>
<p><strong>max_connections</strong> : nombre maximum de connexions acceptées, le défaut est à
  100 ce qui est très peu. Ajoutez un zéro et passez à 1000. Pensez par exemple
  que deux serveurs frontaux apache avec un MaxClients à 150 demanderont 300
  connexions en pic (s'ils ne servent qu'une seule application, avec un seul
  login sur une seule base...). Si vous utilisez Apache en mode multi-threadé
  (worker) vous risquez d'avoir un MaxClients beaucoup plus élevé côté apache,
  si vous utilisez plusieurs rôles cela va aussi augmenter la consommation de connexions. <strong>Pensez à utiliser des pooler de connexions pour des besoins
  dépassants le milliers de connexions.</strong></p>
</li>
<li>
<p><strong>superuser_reserved_connections</strong> : Parmi toutes les connexions disponible
 ce nombre de connexions (3 par défaut) sera réservé au superadmin postgres.
 Cela vous permettra de vous connecter à postgreSQL y compris au moment des pics.
Intégrez dans ce nombre la consommation des membres de l'équipe d'admin et des
logiciels de supervision.</p>
</li>
</ul>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              19/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.5.2. Mémoire</h3>
              
              
                <ul>
<li><a href="http://docs.postgresqlfr.org/9.6/runtime-config-resource.html">http://docs.postgresqlfr.org/9.6/runtime-config-resource.html</a></li>
</ul>
<p>La mémoire est utilisée par PostgreSQL de deux façons, une partie de cette
mémoire est consommée par chaque connexion ouverte. Une seconde partie beaucoup
plus importante est utilisée en tant que mémoire partagée par toutes les
connexions.</p>
<p>Chaque connexion est un processus différent (fork) et la principale particularité
 de PostgreSQL avant la version 9.3 était l'utilisation intensive de cette
 mémoire partagée. La consommation n'est plus aussi importante depuis.</p>
<p>Sur la plupart des distributions les valeurs par défaut pour la mémoire sont très
 faibles, adaptées à une utilisation légère de PostgreSQL par une seul utilisateur.
Ceci parce que la plupart des distributions n'autorisent par défaut que des
valeurs très petites pour la taille d'un fichier de mémoire partagée.
Vous aurez donc assez souvent le besoin de modifier ces paramètres et de modifier
la taille limite des fichiers partagés dans le système.</p>
<p>La mémoire partagée était utilisée pour cacher les données du disque, ce qui
comprenait les données des journaux de transactions et les fichiers des tables
 et autres objets physiques (le contenu du répertoire de données de la base en
 fait).</p>
<p>Avec la version 9.3, PostgreSQL est passé d'une mémoire partagée SysV à une
mémoire partagée Posix (et mmap). Ceci à simplifié les installations et réglages
et n'impose plus la modification de SHMMAX et SHMALL dans la plupart des cas.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              20/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <ul>
<li><strong>wal_buffers</strong> : taille réservé au cache des journaux transactions: 64KB par
 défaut: sur un serveur ou des transactions sont réellement en œuvre (pas
 uniquement des opérations en lecture) utiliser des valeurs entre 1Mo et 10Mo.</li>
<li><strong>shared_buffers</strong> : 128MB par défaut (je crois) taille réservée au cache des
données : le plus est le mieux, plus vous pourrez mapper de vos données physiques
dans ce cache mieux le serveur se portera. Le problème étant que vous devez
disposer de cette mémoire (sinon le serveur va swapper, ce qui serait pire).
On conseille souvent d'utiliser au départ un quart de la mémoire du serveur
(donc 500MB sur un serveur qui dispose de 2Go de RAM). En mode 32bit la limite
est de 2GB. Surveillez la statistique <strong>cache_miss</strong> pour voir si votre
paramètre est trop petit.</li>
</ul>
<p><strong>ATTENTION:</strong> sur Windows ne jamais utiliser plus de 512MB en shared_buffers.
Les performances s'effondrent une fois ce seuil dépassé. Il faudra jouer sur
d'autres paramètres.</p>
<p>Sur les PostgreSQL récents il est conseillé de ne pas dépasser 40 pourcent de la
RAM du serveur sous Linux. Pour que le cache disque de l'OS puisse prendre le
relais.</p>
<p>Quand vous essayerez de démarrer ou redémarrer postgreSQL avec des nouvelles
valeurs dans ces champs il est probable que celui-ci refuse de se lancer à cause
d'une taille de fichier partagé trop importante. Regardez le fichier de log,
celui-ci indique la valeur que le serveur à tenté d'allouer:</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              21/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <pre><code>&gt; /etc/init.d/postgresql-9.6 restart
Restarting PostgreSQL 9.6:
waiting for server to shut down.... done
server stopped
waiting for server to start.......................pg_ctl: could not start server
Examine the log output.
PostgreSQL 9.0 did not start in a timely fashion, please see /path/to/data/pg_log/startup.log for details
&gt; tail -f -n 10 /path/to/data/pg_log/startup.log
(...)
2011-10-26 18:06:29 CEST FATAL:  could not create shared memory segment:
     Argument invalide
2011-10-26 18:06:29 CEST DETAIL:  Failed system call was
     shmget(key=5439001, size=538116096, 03600).
2011-10-26 18:06:29 This error usually means that PostgreSQL's request
for a shared memory segment exceeded your kernel's SHMMAX parameter.
You can either reduce the request size or reconfigure the kernel with
larger SHMMAX.  To reduce the request size (currently 554467328 bytes),
reduce PostgreSQL's shared_buffers parameter (currently 64000) and/or
its max_connections parameter (currently 1004).
If the request size is already small, it's possible that it is less
than your kernel's SHMMIN parameter, in which case raising the request
size or reconfiguring SHMMIN is called for.
The PostgreSQL documentation contains more information about shared
memory configuration.
</code></pre>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              22/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Pour modifier les paramètre SHMIN et SHMMAX on utilise sysctl ainsi:</p>
<pre><code>&gt;# voir les paramètres actuels
&gt; sysctl -a |grep -i shm
kernel.shmmax = 33554432
kernel.shmall = 2097152
kernel.shmmni = 4096
</code></pre>
<p>On mets les nouvelles valeurs dans /etc/sysctl.conf:</p>
<pre><code>kernel.shmmax = 600000000
kernel.shmall = 600000000
</code></pre>
<p>Puis on recharge ces valeurs:</p>
<pre><code>&gt; sysctl -f /etc/sysctl.conf
</code></pre>
<p>Comme tous les serveurs de base de données PostgreSQL <strong>adore la RAM</strong>, pensez
à le séparer des autres processus dévoreurs de RAM comme Apache ou un serveur
J2EE. Donnez lui une machine dédiée, avec aussi des disques rapides et sûrs.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              23/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Pour la <strong>consommation par processus</strong> le paramètre important est :</p>
<ul>
<li><strong>work_mem</strong> : cela représente la mémoire que le processus à le droit
d'utiliser pour effectuer ses opérations de hachage et de tris (celles que le
explain montre). S'il a besoin de plus de mémoire il devra passer par un
<strong>stockage temporaire sur disque</strong> des opérations en cours. La difficulté de ce
 paramètre tient au fait que non seulement il est potentiellement à multiplier
 par le nombre de connexions parallèles (<code>max_connections</code> au pire) mais qu'en
 plus un même processus à le droit de l'utiliser plusieurs fois si la requête
 qu'il exécute comprends plusieurs opérations de hachage (certains explain nous
 ont montré des plans d'exécution complexes où cette work_mem aurait été utilisée
 plusieurs fois pour la même requête). La valeur par défaut est <strong>1MB</strong>.
 Vous pouvez essayer de monter à <strong>10MB</strong> mais pour 1000 connexions parallèles
 qui auraient des requêtes ardues à effectuer cela veut dire potentiellement
 10Go de RAM – il est improbable que toutes les connexions utilisent en même
 temps la maximum de ce qui leur est autorisé). Si vous mettez une valeur trop
 basse vous allez augmenter l'utilisation des fichiers temporaires ce qui
 ralentira le temps d'exécution des requêtes et augmentera l'activité sur disque
 (qui est lente).</li>
</ul>
<p>Vous pouvez affecter cette valeur à l'aide des variables utilisateur, par exemple
au niveau des rôles. Ainsi certains rôles effectuant du travail sur des quantités
importantes de données pourront avoir un work_mem par défaut plus important.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              24/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <ul>
<li><strong>maintenance_work_mem</strong> : 16MB par défaut, montez à 100MB voir plus. Il
 s'agit de la mémoire allouée aux processus du superutilisateur effectuant de
 s opérations de maintenance comme les <strong>vaccuums</strong> ou les <strong>réindexations</strong>,
 les clusters etc. Il n'y a normalement pas de parallélisations de ces tâches</li>
</ul>
<p>Lors d'un import de données massif, il n'y aura à priori que des connexions
destinées à cet import (si vous coupez les autres via le pg_hba.conf par
exemple), pensez à augmenter les valeurs de work_mem et maintenance_work_mem <strong>temporairement</strong> pour accélérer l'import.</p>
<ul>
<li><strong>effective_io_concurrency</strong> : indiquez le nombre de disque présents sur le
 système</li>
</ul>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              25/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Signalons enfin d'autre paramètres proches de l'utilisation mémoire mais qui
sont plus des réglages informatifs:</p>
<ul>
<li>
<p><strong>effective_cache_size</strong> : 128MB par défaut il ne s'agit pas d'un paramètre de
 consommation de mémoire par PostgreSQL. Il s'agit d'un paramètre d'information
 sur le système d'exploitation, la taille de RAM libre disponible pour effectuer
des requêtes. Sur Linux mettez environ 2/3 de la RAM, sur Windows regardez la
valeur du cache disque sur le gestionnaire de tâches. Il s'agit ici d'indiquer à
PostgreSQL la taille du cache disque de l'OS pour que le planificateur de requêtes
calcule la probabilité qu'une table et/ou son index soient dans le cache disque
de l'OS.</p>
</li>
<li>
<p><strong>random_page_cost</strong> : il s'agit d'un indicateur de coût (unité arbitraire)
pour accéder à une page de donnée sur le disque. La valeur par défaut est 4.0.
Si vous pensez que votre machine dispose de disques qui valent mieux que la
moyenne du marché baissez ce coût. Par exemple à 3.0 ou 2.0. Dans l'idéal
faites des benchmarks pour mesurer les gains éventuels sur des requêtes.</p>
</li>
</ul>
<div class="warning"><p>
Ces deux paramètres peuvent jouer en faveur des parcours d'index au lieu de
parcours séquentiels lors de l'exécution des requêtes.
</p></div>


              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              26/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.5.3. Les logs</h3>
              
              
                <p>Il y a de nombreux paramètres liés aux journaux dans le fichier <code>postgresql.conf</code>.</p>
<p>On peut par exemple décider de loger au format <strong>CSV</strong>, de tracer toutes les
requêtes, ou bien aucune, ou bien seulement celles qui modifient la structure
de la base (ddl). On peut associer un explain avec les requêtes tracées,
garder une trace du temps d'exécution, des connections, etc.</p>
<p>Les paramètres les plus importants pour les logs sont:</p>
<ul>
<li><strong>log_min_duration_statement</strong> : indiquez une valeur au dessus de laquelle
 vous garderez une trace de la requête, cela vous permettra d'identifier les
 requêtes qui nécessitent un travail de réécriture ou d'indexation.</li>
<li><strong>log_temp_files</strong> : indiquez une taille, si une requête nécessite la
 création d'un fichier temporaire supérieur à cette taille elle sera loguée.</li>
<li><strong>lc_messages = 'C'</strong> : contrairement aux autres paramètres de locales (comme
les monnaies, ordre de tris, heure) vous devriez laisser les messages dans la
locale par défaut <strong>C</strong>. Ceci vous permettra de retrouver plus vite de l'aide
sur Internet en recopiant les messages d'erreur retrouvés dans les logs.</li>
</ul>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              27/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Si vous voulez tester les logs en CSV vous devrez paramétrer vos logs ainsi :</p>
<pre><code># eventlog &amp; stderr ne sont pas requis pour les logs csv
# mais on voit qu'il s'agit d'une liste et pas d'un réglage
# unique
# windows
#log_destination = 'csvlog,eventlog,stderr'
# linux
log_destination = 'csvlog,syslog,stderr'
logging_collector = on
# Nous changeons le nom de fichier pour par exemple ne garder
# que le nom du jour (lundi)
log_filename = 'postgresql-%a.log'
# Après une semaine le fichier 'lundi' sera réutilisé, il devra
# avoir été remis à vide
log_truncate_on_rotation = on
# Ici si vous essayez de forcer la rotation des logs sur l'age
# ou la taille cela ne devrait plus fonctionner. Sans doute
# parce que l'heure ne figure plus dans log_filename
log_rotation_age = 1440
log_rotation_size = 100kB
</code></pre>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              28/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Si vous voulez importer vos logs CSV dans une table PostgreSQL vous aurez besoin de cette table:</p>
<pre><code>CREATE TABLE postgres_log
(
  log_time timestamp(3) with time zone,
  user_name text,
  database_name text,
  process_id integer,
  connection_from text,
  session_id text,
  session_line_num bigint,
  command_tag text,
  session_start_time timestamp with time zone,
  virtual_transaction_id text,
  transaction_id bigint,
  error_severity text,
  sql_state_code text,
  message text,
  detail text,
  hint text,
  internal_query text,
  internal_query_pos integer,
  context text,
  query text,
  query_pos integer,
  location text,
  application_name text,
  PRIMARY KEY (session_id, session_line_num)
);
</code></pre>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              29/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Ensuite importez le log dans la table:</p>
<pre><code>COPY postgres_log FROM '/chemin/complet/vers/logfile.csv' WITH csv;
</code></pre>
<p>Attendez que le fichier de log ne soit plus utilisé pour l'importer (sinon vous
aurez des problèmes avec la clef primaire en essayant de le réimporter).</p>
<p>Si vous essayez de l'importer depuis une application faites attention au fait que
 certains des champs peuvent contenir des retours chariots et donc être sur
 plusieurs lignes (comme internal_query et message).</p>
<div class="warning"><p>
<b>Certaines traces ne peuvent être poussées dans le csvlog ou l'eventlog</b>,
comme les logs en provenance des erreurs de linkage des librairies partagées
(python, perl) ou des corruptions de mémoire. Vous aurez donc toujours un
fichier de log classique (*.log), qui sera le plus souvent vide, mais n'oubliez
pas de le regarder. Le jour où ce fichier ne sera pas vide ce sera pour des
problèmes critiques <b>« on ne réalise pas qu'on en a besoin jusqu'à ce qu'on en
 ai besoin, et ce jour là on en a vraiment besoin ».</b>
</p></div>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              30/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.5.4. Les journaux de transactions (WAL) et CHECKPOINT</h3>
              
              
                <p>Quand des écritures on lieu dans postgresql il y a toujours une transaction.
Chacune de ces transactions est tracée dans le WAL (Write Ahead Logging).
Nous pouvons d'ailleurs observer que parmis les premiers processus de PostgreSQL
l'un d'entre eux est dédié à cette opération:</p>
<pre><code>&gt;ps auxf|grep postgres
postgres  S      0:00 /path/to/bin/postgres -D /path/to/data
postgres  Ss     0:00  \_ postgres: logger process
postgres  Ss     0:00  \_ postgres: writer process
postgres  Ss     0:00  \_ postgres: wal writer process
postgres  Ss     0:00  \_ postgres: autovacuum launcher process
postgres  Ss     0:00  \_ postgres: stats collector process
</code></pre>
<p><strong>Le WAL enregistre toutes les transactions validées.</strong> Sans pour autant que ces
 opérations soient réellement transférées sur le disque au niveau des tables.
Cela permet la reprise d'un état cohérent de la base en cas d'arrêt brutal, sans
 pour autant ralentir les opérations d'écritures trop fortement en forçant les
 fichiers binaires des tables à être raccord avec l'état réel des données en
 permanence.</p>
<p>Le WAL est constitué de fichiers. Ces fichiers contiennent des copies des pages
 mémoire des tables et des informations de modification à effectuer.
 Quand un fichier WAL est rempli un nouveau fichier WAL est créé. Ces fichiers
 font 16MB. Ils sont stockés dans le répertoire pg_xlog du dossier data de la
 base.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              31/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Les fichiers WAL (journaux) sont stockés dans le dossier <code>pg_xlog</code> du répertoire
 des données. Il peut s'avérer très utile d'utiliser un disque différent sur ce
 point de montage du système de fichier (parallélisation, gestion du disque
cache, taux d'IO du disque). Sur Windows voir les systèmes de JUNCTION.</p>
<div class="warning"><p>
Notez que même <b>une base sans aucune activité en écriture aura des fichiers WAL
 générés dans ce dossier</b>. Ceci parce qu'au moins une opération d'écriture
arrive régulièrement, le <b>CHECKPOINT</b> et que cette opération est elle-même
 enregistrée dans un fichier WAL.
</p></div>

<p>Les checkpoints peuvent se produire à plusieurs moments:</p>
<ul>
<li><strong>'checkpoint_timeout' minutes</strong> (par défaut 5) se sont passées depuis le
 dernier checkpoint</li>
<li>il y a eu <strong>plus de 'checkpoint_segments' fichier WAL créés</strong> (par défaut 3)</li>
<li>quelqu'un à lancé une commande SQL <strong>CHECKPOINT;</strong></li>
</ul>
<p><strong>Lors du checkpoint les changements stockés dans les fichiers WAL sont écrits dans
 les fichiers physiques des tables.</strong></p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              32/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>On peut alors imaginer que l'opération de CHECKPOINT est une <strong>opération coûteuse</strong>
 pour l'OS, toutes les écritures sont reportés à un moment ultime, quand ce
moment intervient un grand nombre d'écritures doivent se faire.</p>
<p>Heureusement on peut répartir ces écritures entre deux checkpoints grâce au
paramètre <strong>checkpoint_completion_target</strong>. La valeur par défaut <strong>0.5</strong>
signifie que PostgreSQL dispose de <code>0.5*checkpoint_timeout</code>, soit 2 minutes 30
par défaut pour effectuer les écritures réelles. En le fixant à <code>0.9</code> on permet
un lissage plus fort encore de ces écritures. Mais vous pouvez aussi repousser
<code>checkpoint_timeout</code> et utiliser une valeur assez basse pour
 <code>checkpoint_completion_target</code>.</p>
<div class="warning"><p>
Remarquez le paramètre <b>checkpoint_warning</b> à <b>30s</b> par défaut.
Si plus de 3 WAL sont créés en moins de 30s un nouveau CHECKPOINT très
rapproché de l'ancien sera généré et vous aurez une ligne de warning dans les
logs, si vous voyez un grand nombre de ces warnings lors d'une activité
régulière de la base cela signifiera que vous devrez <b>augmenter votre valeur
de checkpoint_segments qui est à 3 par défaut</b>.
</p></div>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              33/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide title2">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h2>20.6. Considérations matérielles pour la performance</h2>
              
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              34/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Plus vous aurez de CPU (nombre) plus vous pourrez traiter de requêtes en
 parallèle. Et cela pourra aussi devenir crucial lors de l'utilisation de
 <code>pg_restore</code> pour paralléliser les traitements d'import.</p>
<p>Plus vous aurez de <strong>RAM</strong> plus vous pourrez espérer faire tenir l'intégralité
des données de la base dans le <strong>shared_buffers</strong> (ou dans le cache de l'OS),
ou plus vous aurez la possibilité d'augmenter <code>work_mem</code> afin d'éviter
l'utilisation de tables temporaires sur le disque lors d'un travail d'une
requête sur un grand nombre de données.</p>
<p>Si vous n'avez pas assez de RAM et que vous avez réglé des paramètres
d'utilisation de la RAM trop élevés les performances s'effondreront.</p>
<p><strong>Attention aux programmes tournant sur le même serveur.</strong></p>
<p>Certains type de RAM sont plus sûrs que d'autres (comme la RAM ECC).</p>
<p>les Entrées-Sorties disques seront importante si vous n'arrivez pas à faire
tenir la base dans <code>shared_buffers</code>. Soit parce que votre base est très grande,
soit parce que vous travaillez avec Windows. Si vous activez le WAL pour les
backups ou la réplication les opérations d'écritures vont aussi impliquer des
Entrées-Sortie disque, peut-être devrez-vous prévoir des disques très rapides,
supportant un grand nombre d'Entrées/Sorties, spécifiquement pour le WAL.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              35/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Si vos disques sont en RAID http://fr.wikipedia.org/wiki/RAID_%28informatique%29
 notez qu'un <strong>RAID5</strong> peut ralentir les opérations d'écritures, le meilleur
 système de RAID est le <strong>RAID1+0</strong> (mirroring et agrégation), mais il est assez
coûteux en nombre de disques.</p>
<p>Pour des volumes vraiment très gros vous devrez étudier les différents système
de SAN à disposition, mais évitez les système de disque réseau type NFS ou ISCSI
si vous pouvez utiliser des vrais disques avec du RAID matériel.</p>
<p>Multipliez les <strong>cartes réseau</strong> et ne mélangez pas les différents flux réseaux.
Si vous avez des <strong>flux de réplication</strong> ils ne devraient pas passer par les
mêmes cartes réseau que les flux à destination des serveurs d'application.
Vous pourrez de plus mieux <strong>superviser</strong> les évolutions de trafic des
différents flux. Utiliser un réseau d'administration peut aussi permettre de
régler des <strong>politiques d'accès</strong> (pg_hba.conf) ou d'éviter d'engorger le trafic
 réseau au moment des <strong>sauvegardes</strong>.</p>
<p><strong>Monitorez</strong> et mesurez les impacts des changements de matériel et de configuration</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              36/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide title2">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h2>20.7. Backup et Restaurations liés à l'archivage WAL</h2>
              
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              37/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Nous verrons par la suite que le WAL peut servir à des politiques de <strong>réplication</strong>.</p>
<p>Dans un premier temps nous analyserons sa première utilité qui est de permettre
un backup par sauvegarde des journaux de transactions (associé à un backup de
l'état physique de la base à un instant couvert par ces journaux).</p>
<p>Ce type de backup est très puissant puisque contrairement aux dumps il permet:</p>
<ul>
<li>la sauvegarde des modifications au fil de l'eau</li>
<li>le <strong>PITR (Point In Time Recovery)</strong>, la restauration à un état passé de la base.</li>
</ul>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              38/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.7.1. Configurer l'archivage des WAL</h3>
              
              
                <p>Les fichiers WAL que nous avons étudié avec les principaux paramètres de
configuration permettent de rejouer toutes les transactions qui ne sont pas
encore écrites sur les fichiers physiques.</p>
<p>Cela signifie qu'en partant d'une version ancienne des fichiers physiques de la
base et en rejouant tous les fichiers WAL créés depuis on peut ré-obtenir une
version récente de la base (et on peut s'arrêter à une transaction donnée).</p>
<p>Ce système de backup existe et s'appelle le <strong>WAL Archiving</strong>.</p>
<p>Ceci se fait en indiquant <strong>'archive'</strong> au lieu de <strong>'minimal'</strong> à l'option
<code>wal_level</code> et en activant l'<code>archive_mode</code>, et l'<code>archive_command</code>.</p>
<p>Il faut ensuite configurer quelques paramètres comme indiqué dans cet extrait de configuration commenté :</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              39/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <pre><code># Activation de l'archivage WAL
wal_level = archive

# Ceci va activer la commande d'archivage
archive_mode = on

# Ceci est la commande utilisée par PostgreSQL pour archiver les logs
# %p : chemin du fichier à archiver (le journal de transaction original)
# %f : le nom du fichier sans le chemin
# la commande ne doit retourner 0 en code sortie
# qu'en cas de succès!!!
# Il s'agit ici d'un script de backup incrémental
# Quand le ficher WAL est plein ou trop vieux il sera archivé
# à l'aide de cette commande et un nouveau WAL sera utilisé par
# le serveur
# En cas de succès de l'archivage le fichier WAL peut être
# supprimé ou réutilisé par postgreSQL
# Ici nous pourrions aussi utiliser un script qui au passage ferait
# une compression une utiliser un pipe pour cela (|)
archive_command = 'test ! -f /mnt/serveur/archive/%f &amp;&amp; cp -i %p /mnt/serveur/archive/%f &lt;/dev/null'

# Ceci va forcer l'archivage d'un journal de transaction (WAL)
# même si'il n'y a pas eu beaucoup de modifications.
# Donc en cas de période d'inactivité sur la base nous aurons ic
# le temps le plus long avant qu'une modification ne soit
# réèllement archivée (300s-&gt;5min)
archive_timeout = 300s

# En utilisant la valeur par défaut (on) on indique que les commit
# ne sont considérés réèl qu'après que le WAL soit écrit sur le disque
synchronous_commit = on
</code></pre>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              40/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <pre><code># Ceci est la méthode qui est utilisée pour s'assurer que le fichier
# WAL est synchronisé sur le disque
#"fsync" ou "fsync_writethrough" : Force écriture réèlle sur le disque
# sans que l'OS puisse utiliser son cache disque
# "open_datasync" : valeur par dfaut pour windows mais cela implique
# un cache disque
# "fsync" apelle fsync() à chaque commit,"fsync_writethrough" aussi
# en forcant les « write-through »des caches internes aux disques
wal_sync_method = 'fsync_writethrough'

# checkpoint_completion_target indique que PostgreSQL peut utiliser
# ce % de checkpoint intervall time (5min par défaut)
# pour effectuer les vraies E/S disque lors des checkpoints
# ici on utilise seulement 0.3, car 0.3*15min=4min30s
checkpoint_completion_target = 0.3

# la valeur par défaut est 5min,
# on pourrait la garder mais cela provoque une modif dans le WAL
# toutes les 5 minutes (à cause du checkpoint enregistré dans le WAL)
# Donc comme un fichier WAL ne peut être plus vieuw que 5 minutes
# cela génèrerait un fichier WAL toutes les 5 minutes au moins.
# Nous le poussaons à 15 minutes.
# Cela signifie que les écritures de pages ne se feront sur le disque
# que toutes les 15 minutes si l'activité est faible
# Mais les fichiers WAL sont écrits sur disque à chaque fois eux,
# ce n'est pas trop grave.
# Note: 15 minutes est uniquement un maximum,
# si 3 (checkpoint_segments) sont près un checkpoint sera effectué
checkpoint_timeout = 15min
checkpoint_segments = 3
</code></pre>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              41/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Le point important est <strong>archive_command</strong>. Le but de cette commande d'archivage
est de recopier les fichiers WAL stockés dans le dossier <code>pg_xlog</code> <strong>vers un
endroit sûr</strong>. La commande peut être un script complexe ou une simple ligne de
commande, le résultat est pour PostgreSQL <strong>la certitude que ce WAL a été
recopié à un endroit où il ne craint plus un arrêt brutal du serveur</strong>.</p>
<p>Examinons la paramètres de temps sur la génération de segments et les checkpoints.
Avec un <strong>checkpoint_timeout de 15 minutes </strong>et une base inactive on obtient sur
une frise chronologique:</p>
<pre><code>C: Checkpoint
W: création fichier WAL
WA: archivage fichier WAL

|C---------------C--------------------C--------------------C--------
0               15                  30                    45
|W----WA---------W------WA------------W--------WA----------W-----WA
0    5          15     20           30        35          45    50
</code></pre>
<p>Un fichier WAL est créé toutes les 15 minutes et il est archivé cinq minutes
plus tard par la commande <code>archive_command</code>. Bien sûr en cas d'activité en
écriture sur la base des fichiers WAL peuvent être créés beaucoup plus vite et
seront archivés quand ils auront plus de cinq minutes d'âge.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              42/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Le rôle de la commande d'archivage est de faire une copie de ces fichiers sur un
autre système. Vous pouvez utiliser rsync, ou une simple copie sur un disque
réseau, voir sur un disque dédié à cette tâche.</p>
<p>Les fichiers WAL font <strong>16MB</strong>, avec une base inactive et un WAL tous les quarts
 d'heures cela représente <code>96*16=1.5Go</code> de donnes minimales à archiver par jour.</p>
<p>N'hésitez donc pas <strong>à compresser ces fichiers</strong> lors de l'utilisation de
l'<strong>archive_command</strong>, vous pourrez gagner plus de 90% d'espace disque sur le
backup. Surtout sur les WAL créés en période inactive. Un programme nommé
<strong>pg_compresslog</strong> peut être utilisé à cette fin ainsi:</p>
<pre><code>archive_command = 'pg_compresslog %p - | gzip &gt; /var/lib/pgsql/archive/%f'
</code></pre>
<p>Ce qui nous donnera pour la commande de restauration</p>
<pre><code>restore_command = 'gunzip &lt; /mnt/server/archivedir/%f | pg_decompresslog - %p'.
</code></pre>
<div class="action"><p>
Indiquez ces paramètres dans <b>postgresql.conf</b>, créez un dossier (<b>mkdir
 -p /mnt/serveur/archive; chown -R postgres /mnt/serveur;</b>) qui ne sera pas
déporté mais qui pourrait l'être. Redémarrez PostgreSQL puis testez l'effet du
 programme de génération de commandes (populate_app.php) sur les fichiers
 présents dans pg_xlog et dans votre répertoire d'archivage (/mnt/serveur/archive).
</p></div>


              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              43/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.7.2. Et sur Windows?</h3>
              
              
                <p>Sur une machine Windows on pourrait utiliser pour l'archive_command une commande
 de ce type:</p>
<pre><code>archive_command = 'copy %p E:\\ExternalBackup\\pg_xlog\\%f'
</code></pre>
<p>Un des problèmes par contre sur windows est le <code>wal_sync_method</code> qui est à
<strong>'open_datasync'</strong> par défaut, avec comme indiqué dans le commentaire de ce
 paramètre le problème d'utilisation du cache disque par l'OS.
On peut utiliser <strong>'fsync_writethrough'</strong> ou tester <strong>'open_datasync'</strong> mais il
 faut alors empêcher le cache disque de windows en allant dans:</p>
<pre><code> # My Computer\Open\disk drive\Properties\Hardware\Properties\
                              Policies\Enable write caching on the disk
</code></pre>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              44/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.7.3. Automatiser une sauvegarde WAL</h3>
              
              
                <p>Les 3 opérations qui vont devoir être effectuées lors d'un backup sont:</p>
<ul>
<li><strong>1)</strong> lancer un <strong>SELECT pg_start_backup('iciunechaînedecaractères');</strong>.
  Cette commande va créer un fichier dans le répertoire des données qui
  identifiera le backup en cours. Elle lance aussi un <strong>CHECKPOINT</strong> qui force
  l'écriture des données sur le disque. Si vous passez l'option <code>true</code> en
  deuxième argument ce CHECKPOINT sera forcé, sinon vous devrez attendre la fin
  du CHEKPOINT qui peut dépendre du paramètre <strong>checkpoint_completion_target</strong>
  que vous avez donné. La requête retournera un résultat quand le checkpoint se
  terminera. <em>Si cette commande renvoie des erreurs vous devriez sans doute arrêter le backup (un backup précédent qui ne s'est pas terminé?).</em></li>
<li><strong>2)</strong> Faire <strong>une copie de tout le contenu du répertoire des données.</strong>
  Il n'est pas nécessaire de copier le sous-répertoire pg_xlog. Celui-ci est
  normalement déjà pris en charge par le système d'archivage des WAL.
  Une des techniques de sauvegarde du répertoire des données et d'utiliser un
  système de fichier capable de faire des <strong>snapshots</strong> en faisant des freeze
  des fichiers et en gérant les modifications sur des système temporaires
  (comme XFS par exemple). Si vous pouvez faire un freeze du système de fichier
  juste après le pg_start_backup les opérations de restauration seront
  simplifiées car aucun fichier ne contiendra de données datant de transactions
  ultérieures au début du backup.</li>
</ul>
<p>...</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              45/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <ul>
<li><strong>3)</strong> effectuer un <strong>SELECT pg_stop_backup();</strong> ceci arrête le backup en
  passant au prochain WAL et retire le fichier <code>backup_label</code> du répertoire des
  données (que l'on aura donc copié avec la sauvegarde, mais ce n'est pas grave).
  Si nous sommes en mode <code>archive_mode</code> (backup des journaux de transactions)
  cette commande va attendre jusqu'à ce que le dernier segment WAL soit
  considéré comme archivé (celui qui contenait les dernières opérations
  effectuées en live sur la base pendant que nous faisions la copie binaire du
  répertoire des données entre <code>pg_start_backup</code> et <code>pg_stop_backup</code>).</li>
</ul>
<div class="warning"><p>
Si jamais <b>l'archive_command ne retourne pas 0</b> pour la sauvegarde du dernier
 WAL <b>pg_stop_backup() ne rendra pas la main</b>. Votre script pourra donc
 inclure une gestion du <b>timeout</b>. Votre système de supervision devrait aussi
 vérifier que les backups se terminent (pour Nagios voir les services passifs
 et le paramètre freshness, fraîcheur).
</p></div>


              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              46/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Pour lancer les commandes <strong>SELECT</strong> en début et fin de backup on pourra utiliser
<code>psql</code> avec l'option <code>-c</code>. Ce qui donne par exemple dans un script BAT (windows):</p>
<pre><code>%BINDIR%\psql.exe -h %SERVER% -U %USERNAME% -d %DATABASE% -p %PORT%^
 --no-password --echo-all -c "SET lc_messages=\"en_US\";^
 SELECT pg_start_backup(E'%BACKUPLABEL%');"
IF ERRORLEVEL 1 goto (...)
</code></pre>
<p>Ou dans un script Bash:</p>
<pre><code>${BINDIR}\psql -h ${SERVER} -U${USERNAME} -d ${DATABASE} -p ${PORT} \
 --no-password --echo-all -c "SET lc_messages=\"en_US\"; \
 SELECT pg_start_backup(E'%BACKUPLABEL%');"
if [ $? ne 0 ]; then (...)
</code></pre>
<p>Nous pourrions utiliser <code>rsync</code>, <code>copy</code>, ou un simple <code>tar</code>.</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              47/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Testons un script simpliste (sans gestion d'erreur). Nommons ce script
<strong>backup.sh</strong>, il faut adapter dans ce script le dossier <strong>DATADIR</strong> par rapport
à votre vrai dossier de stockage de la base.</p>
<pre><code>#!/bin/bash
DATADIR=/var/lib/pgsql/data
ARCHIVEDIR=/mnt/serveur/archive
BACKUPDIR=/mnt/serveur/backup
# demarrage du backup
psql --username=postgres -d postgres -c "select pg_start_backup('hot_backup');"
# backup binaire
tar -cf ${BACKUPDIR}/backup.tar ${DATADIR}
# fin du backup
psql --username=postgres -d postgres -c "select pg_stop_backup();"
</code></pre>
<p>Il nous faut rendre ce script exécutable et prévoir le dossier de stockage du backup:</p>
<pre><code>chmod u+x backup.sh
sudo mkdir /mnt/serveur/backup/
</code></pre>
<p>Lancez le script. Vous pouvez normalement faire tourner le script php
<code>populate_app.php</code> en parallèle du backup.</p>
<pre><code>sudo ./backup.sh
</code></pre>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              48/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.7.4. Recovery: Restaurer un archivage de WAL</h3>
              
              
                <p>Maintenant que nous avons au moins une copie de la base et un archivage des
journaux de transaction nous devrions pouvoir tester une restauration.</p>
<p>Quelques notes utiles sur <strong>les restaurations</strong>:</p>
<ul>
<li>les segments de WAL qui ne seront pas retrouvés à l'emplacement d'archivage
 seront recherchés dans le dossier <code>pg_xlog</code> de la base s'il existe encore (nous
 somme en procédure de recovery, si ça se trouve on a plus ce dossier). Par
 contre <strong>les segments présents dans le dossier d'archivage seront prioritaires</strong>.</li>
<li>Avec une restauration on peut voir la gestion du temps dans PostgreSQL comme
  une <strong>gestion parallèle du temps</strong>. Un monde parallèle dans lequel les
  transactions de la restauration et les transactions éventuellement présente
  dans des WAL locaux ne seront pas mélangés.</li>
<li>Normalement une restauration va reprendre tous les WAL qu'elle a à disposition, et donc ramener la base à un point dans le temps qui est le plus proche possible du présent. Normalement une restauration se termine avec un message dans les logs signalant un équivalent de « file not found », rien d'alarmant. Il peut aussi y avoir un message d'erreur en début de restauration sur un fichier 00000001.history, ce n'est pas non plus un vrai problème.</li>
</ul>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              49/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <ul>
<li>
<p>La commande miroir de <strong>archive_command</strong> est <strong>restore_command</strong>. Elle doit
  permettre de <strong>récupérer les segments archivés</strong>. Comme la première cette
  commande doit renvoyer un code de sortie autre que 0 en cas d'erreur.
  Cette commande devra figurer dans un fichier <code>recovery.conf</code> situé dans le
  répertoire de la base.</p>
</li>
<li>
<p>Il est possible d'écrire des fichiers <strong>recovery.conf</strong> avancés et de les stocker
  dans le répertoire des données de la base avant la restauration. Ceci permet
  le <strong>Point in Time Recovery (PITR)</strong> qui permettra de s'arrêter à un <strong>temps</strong>
  ou un <strong>numéro de transaction</strong> donné. Ce point dans le temps doit être situé
  <strong>hors du temps du backup</strong>. Il ne peut être situé entre le temps du
  <code>pg_start_backup()</code> et du <code>pg_stop_backup()</code>. Des exemples de <code>recovery.conf</code>
  sont disponibles et commentés dans <code>recovery.conf.sample</code> qui est livré avec le
  package ou les sources (dossier share).</p>
</li>
</ul>
<p>Nous allons donc nous créer une situation de crash, un fichier de configuration
 spécifiquement dédié à la restauration (optionnel), un fichier de recovery
 (obligatoire) puis tenter cette restauration.</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              50/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.7.5. Fichier de configuration dédié à la restauration</h3>
              
              
                <p>Au moment d'une restauration vous allez avoir de nombreux <strong>journaux de
transactions à rejouer</strong>, ou bien un <strong>dump important à intégrer</strong>. Il sera très
certainement utile de <strong>préparer à l'avance un fichier de configuration
 optimisé</strong> pour les restaurations. Stockez ce fichier à côté du fichier
 <code>postgresql.conf</code> officiel et utilisez-le le jour J.</p>
<pre><code>cp postgresql.conf postgresql.restore.conf
cp postgresql.conf postgresql.orig.conf
</code></pre>
<p>Vous pouvez aussi utiliser ces réglages sur les <strong>machines de développement</strong> si
 la stabilité de la base n'est pas une priorité par rapport au temps de réponse
puisqu'il s'agit d'un fichier <strong>optimisé en vitesse d'exécution</strong> et non en
intégrité des données physiques.</p>
<p>Éditez donc cette copie postgresql.restore.conf puis changez ces paramètres:</p>
<pre><code># Ne pas tout mettre dans les fichiers WAL
# par exemple exclure les instructions COPY du dump
wal_level = minimal
# va désactiver l'archivage des WAL, ils ne sont donc plus archivés.
archive_mode = off
# repousser les écritures disques rèlles
# (très dangereux en cas d'arrêt brutal de la base ou de l'OS)
fsync = off
synchronous_commit = off
wal_sync_method = 'open_sync'
</code></pre>
<p>...</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              51/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <pre><code># repousser les checkpoints à un temps très long
checkpoint_timeout = 30min
# repousser le checkpoint pour qu'il n'intervienne qu'après
# un nombre très grands d'écritures de fichiers WAL
checkpoint_segments = 5000

# ici nous utilisons 0.00001, car 0.0001*30min est un chiffre très bas
# (180ms je crois) et que cela prendra de toute façon plus de
# temps dans la réalité
checkpoint_completion_target = 0.00001

# Si nous ne sommes pas sur windows on peut tenter une valeur
# très élevée du stockage des journaux de transactions en mémoire
# dans le segment de mémoire partagée
# sur windows un 64kb suffira, sur Linux 16MB est très bien
wal_buffers=16MB

# donnons plus de mémoire pour les opérations DDL
maintenance_work_mem = 500MB

# désactivation des stats
track_activities = off
track_counts = off

# désactivation de l'autovacuum
autovacuum = off

# On s'assure de ne pas charger trop de modules annexes
shared_preload_libraries = ''
custom_variable_classes = ''
# et on enleve les settings des modules complémentaires s'il y en a
</code></pre>
<p>...</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              52/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <pre><code># Assurons nous de ne pas avoir trop de logs
log_destination = 'stderr'
debug_print_parse = off
debug_print_rewritten = off
debug_print_plan = off
debug_pretty_print = off
# Ceci peut s'avérer utile pour vérifier que le checkpoint n'est
# pas lancé et regarder combien de buffers sont écrits lors des
# checkpoints manuels avec la commande CHECKPOINT;
log_checkpoints = on
log_connections = off
log_disconnections = off
log_duration = off
log_error_verbosity = default
log_hostname = off
log_statement = 'none'
log_temp_files=-1
</code></pre>
<p>On teste ce fichier (assurez d'avoir une copie du postgresql.conf original avant de mettre celui-ci en place)</p>
<pre><code>cp postgresql.conf postgresql.orig.conf
cp postgresql.restore.conf postgresql.conf
/etc/init.d/postgresql-9.6 restart
</code></pre>
<p>Testez le script <code>populate_app.php</code> sur cette version de PostgreSQL. Vous
devriez obtenir des <strong>gains de vitesse très très importants</strong>. Mais vous n'avez
plus en face un serveur de base de données très sûr en terme de stockage disque.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              53/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.7.6. Créer un crash</h3>
              
              
                <p><strong>On va retirer le DATADIR de postgreSQL</strong>, soit pendant qu'il tourne soit à
l'arrêt, la situation est la même, vous n'aurez plus de PostgreSQL et la base
est « perdue ». Sur Linux un <code>kill -9</code> des processus postgres pour tuer
brutalement le serveur sera utile. Le <code>mv</code> du dossier pouvant ne pas suffire
à lui faire perde ses descripteurs de fichiers.</p>
<p>Si nous prenons <code>/var/lib/pgsql/data</code> comme DATADIR il suffit de faire (en root):</p>
<pre><code>mv /var/lib/pgsql/data /mnt/otherdisk/olddata;
mkdir /var/lib/pgsql/data;
chown postgres:postgres /var/lib/pgsql/data;
</code></pre>
<p>Dans cet exemple nous avons à disposition les WAL archivés dans
<code>/mnt/serveur/archives</code> et un tar des fichiers physiques de la base dans
 <code>/mnt/serveur/archives</code>.</p>
<p>Vous pourrez tenter une variante de la restauration en recopiant les WAL de
<code>/mnt/otherdisk/olddata/pgxlog</code> dans <code>/var/lib/pgsql/data/pgxlog</code></p>
<p>Faites une copie de vos fichiers <code>postgresql*.conf</code> ou refaites le backup, car
ces fichiers là ne sont pas dans le tar que nous avons fait initialement.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              54/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.7.7. Lancer la restauration</h3>
              
              
                <p>Modifiez <strong>pg_hba.conf pour n'autoriser que les accès locaux</strong>. Par exemple en
indiquant uniquement:</p>
<pre><code>local   all             postgres                             trust
</code></pre>
<p>Ceci afin qu'aucune connexion cliente ne vienne troubler vos opérations.</p>
<p>Recopiez le dernier snaphot binaire effectué dans <code>/var/lib/pgsql/data</code> à la
racine puis décompressez le (sous sa forme actuelle le tar a stocké les chemins
absolus)</p>
<pre><code>cp /mnt/serveur/backup/backup.tar /
cd /
tar xvf backup.tar
</code></pre>
<p>Vérifiez que le fichier <code>postgresql.conf</code> du DATADIR est bien le fichier
optimisé pour les recovery.</p>
<p>...</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              55/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Créez un fichier <code>recovery.conf</code> et stockez le dans le DATADIR. Vous pouvez
utiliser une copie du sample ou bien n'indiquer que l'option <code>restore_command</code>
dans ce fichier:</p>
<pre><code>restore_command = 'cp -i /mnt/serveur/archive/%f %p'
</code></pre>
<p>Sur Windows on aurait quelque chose comme:</p>
<pre><code>restore_command = 'copy "E:\\ExternalBackup\\archives\\%f" "%p"'.
</code></pre>
<p>Mais utiliser un script plus complexe qu'un simple copy peut-être utile,
notamment pour s'assurer qu'un FILE NOT FOUND devrait retourner une code de
sortie 0.</p>
<p>Si votre <code>archive_command</code> compressait les WAL la <code>restore_command</code> doit les décompresser. Si vous utilisiez <code>pg_compresslog</code> vous devez utiliser
<code>pg_decompresslog</code>.</p>
<p>Cette commande va permettre à PostgreSQL de retrouver des segments de WAL afin
de les recopier dans le <code>pg_xlog</code> local s'il en a besoin pour remettre l'état
 binaire des fichiers physiques de la base à jour.</p>
<p>Pour le PITR regardez les paramètres <code>recovery_target_time</code> et
<code>recovery_target_xid</code>.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              56/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <div class="warning"><p>
<b>Attention:</b> PostgreSQL va essayer de renommer le fichier <b>recovery.conf</b>
 en <b>recovery.old</b> à la fin du processus. L'utilisateur postgres doit donc
 être en mesure de bouger ce fichier, n'oubliez pas de lui donner les droits sur
 recovery.conf!
</p></div>

<pre><code>chown postgres recovery.conf
</code></pre>
<p>Vous pouvez retirer le <code>backup_label</code> du DATADIR. Ici nous utilisons les <strong>WAL
 archivés</strong> et nous n'avons plus de WAL dans le <em>'vrai'</em> <code>pg_xlog</code>. Ce fichier
 contient des infos sur les derniers pg_xlog locaux valides, <strong>mais ils ne sont
 plus là</strong>.</p>
<p>Nous devrions être maintenant près pour lancer cette restauration (au fait, il
est évident qu'il vaut mieux avoir testé ces éléments et <strong>rédigé une procédure</strong>
avant d'en avoir besoin).</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              57/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h4>Restauration</h4>
              
              
                <p>Démarrez PostgreSQL</p>
<pre><code>/etc/init.d/postgresql-9.6 start
</code></pre>
<p>Vous pouvez faire un <code>tail -f</code> sur le log actif afin d'observer la restauration.</p>
<p>S'il n'y a pas de messages de restaurations retentez le démarrage jusqu'à ce que
 ceux-ci apparaissent dans les logs.</p>
<p>Attendez tant que les messages soient du type:</p>
<pre><code>CET FATAL:  the database system is starting up
</code></pre>
<p>La fin de la restauration se traduit par un message:</p>
<pre><code>CET LOG: database system is ready to accept connections
</code></pre>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              58/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.7.8. Finir la restauration: tout remettre en état</h3>
              
              
                <p>Après la restauration on lancera à la main (en SQL) un</p>
<pre><code>CHECKPOINT;
</code></pre>
<p>Quand cette commande se termine <strong>la restauration est terminée</strong> et les fichiers
écrits sur disques (ou dans le cache disque de l'OS au moins, vous pouvez taper
sync dans une console root).</p>
<ul>
<li>
<p>Il est conseillé ensuite d'éteindre postgreSQL puis de<strong> remettre le fichier postgresql.conf original</strong>.</p>
</li>
<li>
<p>Remettez aussi le <strong>pg_hba.conf</strong> original en place.</p>
</li>
<li>
<p>Redémarrez PostgreSQL</p>
</li>
</ul>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              59/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Tapez ensuite un</p>
<pre><code>VACUUM ANALYZE
</code></pre>
<p>Cette commande va permettre à l'analyseur de remettre à jour toutes ses
statistiques, PostgreSQL mettra moins de temps à effectuer les bonnes opérations
 en fonction de la taille réelle des données. Même si vous n'avez pas utilisé un
fichier de configuration dédié à la restauration, dans lequel les statistiques
étaient suspendues, lancer cette commande accélèrera le retour « à la normale ».</p>
<p>Avec la restauration et la coupure des archivages de WAL la chaîne de PITR/WAL à
 été brisée. Il faut donc <strong>refaire un backup complet des fichiers binaires de
 la base</strong>, afin que ceux-ci puissent servir de base à <strong>la prochaine
 restauration</strong>.</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              60/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide title2">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h2>20.8. Tests de restauration de dump</h2>
              
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              61/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Nous avons vu une <strong>récupération de base à partir des journaux de transactions.</strong></p>
<p>Cela n'exclut pas la possibilité d'effectuer<strong> des opérations de dumps et de
 restauration de dumps</strong> (c'est par exemple obligatoire pour les migrations de
 version majeures).</p>
<p>Effectuez un dump au format compress de votre base avec l'option utf8.</p>
<pre><code>pg_dump --host localhost --port 5432 --username "postgres" --format custom \
  --blobs --encoding UTF8 --verbose --file "/path/to/formation_dump.backup" \
  "formation"
</code></pre>
<div class="action"><p>
Testez la commande de restauration du dump avec les deux configurations <b>postgresql.orig.conf</b> et <b>postgresql.restore.conf</b>
</p></div>

<p>A titre d'exemple sur un serveur Windows (donc pas le plus performant pour
postgreSQL) et avec un dump d'une base de 653MB – donnée obtenue avec un
<code>pg_size_pretty(pg_database_size('name'));</code> -- la différence de configuration
permet de passer de <b>10 minutes et 40s</b> à <b>2 minutes et 49s</b>
(8410 buffers dans le checkpoint). Sur la base formation avec 5000 commandes
le temps varie sur un poste Linux de <b>20s</b> à moins de <b>1s</b>.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              62/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Commande de test sur Windows:</p>
<pre><code>set foo1=%TIME%
"C:/Program Files/PostgreSQL/9.0/bin\pg_restore.exe" --host localhost^
  --port 5432 --username "postgres" --dbname "formation" --disable-triggers^
  --no-data-for-failed-tables --clean --verbose "C:\Temp\formation_dump.backup"
set foo2=%TIME%
echo %foo1%
echo %foo2%
</code></pre>
<p>Commande de test sur Linux:</p>
<pre><code>time  pg_restore --host localhost --port 5432 --username "postgres" \
 --dbname "formation" --disable-triggers --no-data-for-failed-tables \
 --clean --verbose /path/to/formation_dump .backup
</code></pre>
<p>On peut alors tester la parallélisation sur <code>pg_restore</code> avec l'option
<code>--jobs=nb</code> (uniquement pour les formats de dump « compress »). indiquez le
nombre de processeurs de votre serveur et essayez de le multiplier par deux
ensuite. Ce qui pourrait par exemple faire 4 jobs en parallèle pour la
restauration (attention on ne peut plus utiliser <code>--single-transaction</code> ici).</p>
<pre><code>time  pg_restore --host localhost --port 5432 --username "postgres" \
  --dbname "formation" --disable-triggers --no-data-for-failed-tables \
  --clean --verbose --jobs=4 /path/to/formation_dump.backup
</code></pre>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              63/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Notez aussi qu'avec la configuration par défaut de <strong>postgresql.conf</strong> (la
version non optimisée pour un restore) il y a des chances pour que vous
n'observiez aucune différence avec la parallélisation. N'hésitez pas à augmenter
les chiffre si vous avez des CPU multithreadé et autres techniques multi-coeurs.</p>
<p>Pour ceux qui veulent plus d'infos sur les restaurations de grosses bases de
données voici <a href="http://www.depesz.com/index.php/2009/09/19/speeding-up-dumprestore-process/">une histoire utile</a>,
 dans cet exemple la restauration se situe sur une phase de <code>pg_upgrade</code>, donc
 un changement de version majeure de PostgreSQL qui demande un passage par le
 <strong>dump &amp; restore</strong>.</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              64/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide title2">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h2>20.9. Intégrité des données</h2>
              
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              65/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>PostgreSQL s'assure que les données écrites sur le disque sont valides et bien
écrites, en travaillant à plusieurs niveaux ces vérifications d'écritures,
en stockant des pages mémoire dans les WAL, etc. Malheureusement une fois ces
données stockées sur le disque la prise en compte des défaillances du disque
n'est pas faite par PostgreSQL.</p>
<ul>
<li><a href="http://docs.postgresqlfr.org/9.5/wal.html#wal-reliability">http://docs.postgresqlfr.org/9.5/wal.html#wal-reliability</a></li>
</ul>
<p>Depuis PostgreSQl 9.3 des sommes de contrôle CRC sont utilisés à divers endroits
pour se protéger des erreurs d'intégrité de données sur les disques (des bits
qui disparaîtraient).</p>
<p>Il n'y a pas par contre de protection contre des problèmes d'intégrité en RAM.</p>
<ul>
<li><a href="http://www.postgresql.org/docs/9.5/static/wal-reliability.html">http://www.postgresql.org/docs/9.5/static/wal-reliability.html</a> : ici on
trouvera des conseils divers sur les réglages de disques sur les différents OS
afin d'éviter par exemple que le disque stockant les WAL ne soit en mode cache d'écriture.</li>
</ul>
<p>Pensez aussi à spécifier les options du système de fichier dans les points de
montage. Ainsi un système ext3 sera plus rapide avec <code>--data=writeback, noatime,
 nodiratime</code> sans que l'intégrité du système de fichier soit diminuée.</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              66/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide title2">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h2>20.10. Exemple de Politique de backups</h2>
              
              
                <p><small>Nous présentons ici une politique de backups. Il peut en exister
d'autres.</small></p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              67/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.10.1. Backup incrémental</h3>
              
              
                <p>L'archivage des WAL est mis en place. A chaque fois qu'un fichier WAL de 16MB
est près ou qu'il est trop vieux il est recopié dans un répertoire externe à la
base (1er niveau de backup). Ce dossier est synchronisé sur un serveur distant
toutes les heures (2ème niveau de backup des WAL).</p>
<p>Les fichiers WAL sont compressés, et les fichiers trop vieux (voir ci-dessous la
 partie snapshot) seront effacés du serveur de backup.</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              68/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.10.2. Snapshot</h3>
              
              
                <p>Toutes les nuits une <strong>copie binaire des fichiers physiques</strong> de la base devrait
être effectuée. Cette copie serait effectuée <strong>en parallèle</strong> du fonctionnement
de l'archivage des journaux de WAL en utilisant les commandes de backup de
PostgreSQL.</p>
<p>Grâce à cette copie binaire associée à l'archivage des WAL (backup incrémental),
 des restaurations PITR seront possibles. Le fait de disposer d'une version
binaire de la base à J-1 permet de n'avoir pas trop de journaux WAL à rejouer
lors des restaurations.</p>
<p>Suivant le nombre de jours que l'on veut pouvoir remonter sur un PITR on devra
organiser le backup des différentes versions binaires de la base et des WAL
associés (si on veut pouvoir remonter à n'importe quelle transaction survenue
entre J-7 et J il faut une version de la base à J-8 et tous les WAL intervenus
depuis).</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              69/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.10.3. Dump</h3>
              
              
                <p>Le rythme pourrait être <strong>quotidien</strong>.</p>
<p>Extraction quotidienne d'un dump de la base au format compress (*.backup).</p>
<p>Le dump est capable de détecter une corruption de page.</p>
<p>Les dumps permettent une récupération plus simple que les solutions basées sur
les WAL et peuvent prendre le relais en cas de corruption du système de backup
des WAL.</p>
<p>Lors du dump tous les indexs sont parcourus et des « page faults » peuvent être
 détectées et faire échouer le dump.</p>
<p>En parallèle des dumps des différentes bases de données un <code>pg_dumpall</code> devrait
être lancé pour sauvegarder <strong>les tables systèmes</strong>, les <strong>rôles et les GRANT</strong>
d'accès aux bases.</p>
<pre><code>pg_dumpall --globals-only -f DESTINATION
</code></pre>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              70/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.10.4. Réindexation</h3>
              
              
                <p>Une réindexation complète des bases, par exemple chaque semaine, peut permettre
d'éviter la corruption des index par un problème hardware. Lors d'un REINDEX les
index sont reconstruits de zéro. Si vous utilisez des index de type hash cela
évitera aussi des corruptions d'index suite à des restaurations.</p>
<p>Pour accélérer les opération de réindexation n'hésitez pas à modifier à la volée
 le paramètre <code>maintenance_work_mem</code> dans le script SQL avec une instruction
<strong>SET</strong>.</p>
<p>Lors du REINDEX les tables qui subissent ces ré-indexations sont lockées en
écriture mais pas en lecture. Cela signifie qu'il est possible de faire tourner
les réindexations en parallèle des opérations de dump. Pour une base madatabase
les commandes à utiliser sont:</p>
<pre><code>REINDEX SYSTEM madatabase;
REINDEX DATABASE madatabse;
</code></pre>
<p>la commande <strong>CLUSTER</strong> par contre qui utiliserait un index pour réordonner le
contenu d'une table sur disque <strong>bloquerait des opérations de lecture</strong>
parallèles</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              71/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.10.5. Restaurations</h3>
              
              
                <p>En s'appuyant sur la politique de backup présentée, en cas de problèmes nous
avons 4 cas:</p>
<ul>
<li><strong>cas 1)-</strong> il s'agissait d'un <strong>arrêt brutal du serveur</strong> (oups le fil),
  nous allons relancer le serveur et tout sera remis en place par le <code>pg_xlog</code>.
  Vous avez éteint le courant. Quand PostgreSQL va se relancer il va rejouer
  les transactions qui ne sont pas dans le stockage binaire des tables (en
  dehors des WAL qui ne sont pas passés au checkpoint la dernière écriture de
  <strong>CHEKPOINT</strong> en cours ne s'est peut-être même pas terminée proprement).
  <strong>Vous n'avez rien à faire.</strong> En fait il n'y a pas de problèmes, PostgreSQL
  travaille pour vous.</li>
</ul>
<p>Maintenant examinons les 2 cas ou vous n'arrivez pas à relancer le serveur à
cause d'un problème un peu plus important. Par exemple le répertoire des
binaires ou le répertoire des <code>pg_xlog</code> ont disparus (mauvaise journée quand
même...)</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              72/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <ul>
<li><strong>cas 2)-</strong> vous avez votre backup de premier niveau des WAL
  La commande d'archivage des WAL recopie les WAL quelque part, si vous avez
  encore ce « quelque part » vous n'avez pas tout perdu. Vous avez avec vous
 <strong>les journaux de transactions du backup incrémental</strong> (leur âge est au pire de
 15 minutes (max_checkpoint)) et vous avez <strong>le dernier snapshot de la base</strong>
 qui a eu lieu la nuit dernière donc vieux d'un jour maximum.</li>
</ul>
<p>La procédure résumée en ligne :
<a href="http://www.postgresql.org/docs/9.5/static/continuous-archiving.html#BACKUP-PITR-RECOVERY">http://www.postgresql.org/docs/9.5/static/continuous-archiving.html#BACKUP-PITR-RECOVERY</a></p>
<p>Mais peut être possédez vous une procédure encore plus détaillée, adaptée à
votre cas, que vous avez déjà testé au moins une fois sur vos machines.</p>
<p>Nous avons déjà effectué cette procédure lors du teste de recovery. Ajoutons
simplement qu'il ne faut pas hésiter à faire une copie du répertoire <code>pg_xlog</code>
 du DATADIR actuel s'il est encore présent.</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              73/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <ul>
<li><strong>cas 3)-</strong> Vous <strong>n'avez plus le backup des WAL de 1er niveau</strong>.
  Allez chercher les WAL sur le 2ème niveau (serveur de backup).
  Vous devriez alors avoir <strong>les journaux de transactions du backup
  incrémental</strong> (leur âge est au pire de 1 jour si votre backup de 2ème niveau
  est quotidien, une heure s'il est horaire) et vous aurez <strong>un snapshot de la
  base</strong> qui sera vieux d'une semaine (au pire) à 1 jour (au mieux)</li>
</ul>
<p>Procédure:</p>
<ul>
<li>Allez cherchez les données sur le serveur de backup</li>
<li>Effectuez la même procédure que pour le cas2, sauf que vous aurez sans doute
  perdu un jour de transaction, ou bien une heure de transactions (suivant le
  rythme de votre backup de 2ème niveau des WAL).</li>
</ul>
<p>Procédure <strong>alternative</strong>:</p>
<ul>
<li>utilisez <strong>le dernier dump de la base</strong>. Qui devrait être vieux d'un jour au pire</li>
</ul>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              74/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <ul>
<li>
<p><strong>cas 4)-</strong> Vous avez <strong>une corruption de donnée suite à un problème
 matériel</strong>. Vous pouvez détecter ce type de problème suite à un pg_dumpall ou à
 un pg_dump, ou bien certaines requêtes sont rejetées avec des erreurs qui
 signalent que quelque chose est cassé.</p>
</li>
<li>
<p><strong>a)</strong> <strong>suspendez l'accès</strong> à PostgreSQL (modifiez le pg_hba.conf)</p>
</li>
<li>
<p><strong>b)</strong> essayez de <strong>backuper le maximum de choses</strong> de la base actuelle,
  mais le dump est cassé, donc:</p>
</li>
<li>
<p><strong>--1.</strong> fixer le problème matériel si cela est possible</p>
</li>
<li><strong>--2.</strong> démarrez par un snapshot binaire des fichiers de la base (utilisez
 les scripts de backups prévus pour cela)</li>
<li><strong>--3.</strong> essayez de triturer <strong>pg_dump</strong> pour qu'il sauve un maximum de choses.
 Par défaut <code>pg_dump</code> s'arrête sur un « page fault ». Nous allons dire à
 PostgreSQL de vider les données qui provoquent des « page fault » – ici nous
 perdrons des données – et de continuer le dump sur les données valides.
 Ajoutez temporairement le paramètre <code>zero_damaged_pages</code> dans postgresql.conf
 et redémarrez postgreSQL.</li>
</ul>
<div class="warning"><p>
<b>Perte de données.</b> Avec ce paramètre à chaque fois que PostgreSQL
rencontre une page cassée sur le disque il la vide. Alors que par défaut il
s'arrête.
</p></div>

<pre><code>zero_damaged_pages=on
</code></pre>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              75/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <ul>
<li><strong>c)</strong> faites un <code>pg_dumpall</code> complet (vous pouvez le faire avec
 <code>--globals-only</code>), vous aurez des avertissements, à chaque perte de données.
 N'oubliez pas de faire un <strong>pg_dump au format 'c' compress</strong> pour chaque base
 de données. Le format compress sera utilise pour les restaurations partielles
 alors que le pg_dumpall travaille en SQL pur.</li>
<li><strong>d)</strong> enlevez le paramètre <code>zero_damaged_pages</code> et redémarrez PostgreSQL</li>
<li><strong>e)</strong> Essayez d'identifier les données perdues. Un diff avec les précédents
 dump sauvegardés, retransformés en SQL pur à partir de serveurs différents,*
 peut vous aider</li>
<li><strong>f)</strong> faire un <strong>REINDEX</strong> sur tous les index existants ou sur les bases
 directement, il y a des chances que eux aussi aient été endommagés.
...</li>
</ul>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              76/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>On réindexe d'abord le catalogue. L'instruction de réindexation a besoin d'une
base de données en argument pour accéder au catalogue. Le catalogue est le même
sur toutes les bases, ce n'est donc pas la peine de relancer <strong>REINDEX SYSTEM</strong>
sur toutes les bases ensuite.</p>
<pre><code>REINDEX SYSTEM nomdunebasededonnees ;
</code></pre>
<p>Puis pour chaque base:</p>
<pre><code>REINDEX DATABASE dbname;
</code></pre>
<p>Si les index system (pg_catalog) sont cassés PostgreSQL pourrait refuser de
démarrer. Démarrez alors PostgreSQL avec l'option <code>-P</code> pour qu'il effectue des
vérifications sur les index system. Regardez aussi cette page pour voir ce que
vous pourriez faire:</p>
<p><a href="http://www.postgresql.org/docs/9.5/static/runtime-config-developer.html">http://www.postgresql.org/docs/9.5/static/runtime-config-developer.html</a></p>
<ul>
<li><strong>g)</strong> rétablissez le <strong>ph_hba.conf</strong> et relancez PostgreSQL</li>
<li><strong>h)</strong> faites une pause</li>
</ul>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              77/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide title2">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h2>20.11. Utiliser les WAL pour la réplication</h2>
              
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              78/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Nous avons utilisé les WAL pour faire de la <strong>restauration</strong>.</p>
<p>Ce type de fonctionnement peut être étendu pour faire de la <strong>réplication
maitre-esclave</strong>.</p>
<p>Utiliser l'archivage des journaux de logs pour de la réplication signifie que
cette réplication sera <strong>asynchrone</strong> (il faut attendre l'archivage d'un certain
nombre de transactions et leur transfert sur l'esclave).</p>
<p>Cette réplication existe depuis PostgreSQL 8.2 grâce à l'utilitaire
 <strong>pg_standby</strong> et est appelée <strong>WARM STANDBY</strong>, avec un défaut important qui
est <strong>l'impossibilité d'accéder au serveur esclave tant qu'il est en mode
réplication</strong>, il faut effectuer une <strong>bascule manuelle</strong> de cet esclave pour
qu'il puisse prendre le relais du maître (il s'agit en fait d'une restauration
en continu, pour être prêt à reprendre le service plus rapidement).</p>
<p>PostgreSQL9 introduit une amélioration de cette réplication appelée
<strong>HOT STANDBY</strong> qui permet <strong>l'accès en lecture au serveur esclave</strong>.</p>
<p>Une deuxième amélioration consiste à utiliser la réplication par flux de
transactions (<strong>STREAMING REPLICATION</strong>) , et permet d'obtenir un <strong>esclave sans
décalage dans le temps</strong>.</p>
<p>Suivant les versions successives de PostgreSQL 9.x plusieurs améliorations
diverses ont eu lieu au niveau des processus de réplication
(<em>cascading streaming</em>, <em>streaming-only</em>, <em>multiple synchronous standbys</em>),
ainsi que l'ajout d'éléments de base pour les réplications master-master.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              79/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>De très bons article publiés dans Linux Magazine France et rédigés en français
par Guillaume Lelarge donnent des procédure détaillées sur la mise en place de
tels système de réplication:</p>
<ul>
<li><a href="http://www.dalibo.org/hs44_la_replication_par_les_journaux_de_transactions">http://www.dalibo.org/hs44_la_replication_par_les_journaux_de_transactions</a></li>
<li><a href="http://www.dalibo.org/glmf131_mise_en_place_replication_postgresl_9.0_1">http://www.dalibo.org/glmf131_mise_en_place_replication_postgresl_9.0_1</a></li>
<li><a href="http://www.dalibo.org/glmf131_mise_en_place_replication_postgresl_9.0_2">http://www.dalibo.org/glmf131_mise_en_place_replication_postgresl_9.0_2</a></li>
</ul>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              80/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.11.1. Limites</h3>
              
              
                <p>Pour que deux serveurs fonctionnent en mode réplication par les journaux de
transactions il faut qu'ils respectent certaines contraintes:</p>
<ul>
<li>il doivent avoir la même version majeure de PostgreSQL. Le format binaire des
  données pouvent être modifié lors d'un changement majeur de version.</li>
</ul>
<p>9.<strong>0.4</strong> et 9.<strong>0.5</strong> seront <strong>compatibles</strong></p>
<p>9.<strong>0.4</strong> et 9.<strong>1.0</strong> ne le sont <strong>pas</strong></p>
<ul>
<li>il faut être consistant au niveau du stockage binaire (32bit litlle endian
 != 64 bits big endian).</li>
<li>Une des autres limitation de ce type de réplication est qu'il concerne
 <strong>l'ensemble d'un cluster PostgreSQL</strong>, on ne travaille pas sur une base de
 données unique ou sur un set de tables unique (voir les replications par
 triggers type Slony et Londiste pour cela).</li>
</ul>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              81/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.11.2. WARM STANDBY</h3>
              
              
                <p>Obtenir des serveurs en <strong>WARM STANDBY</strong> est assez proche de la problématique de
la restauration basée sur les WAL. Travaillez en binôme. L'un des deux serveurs
sera le maître et l'autre l'esclave.</p>
<p>On commence par arrêter les serveurs PostgreSQL sur le maître et l'esclave.</p>
<p>Sur le maître on garde notre configuration où les WAL sont archivés avec
l'archive_command. Nous allons simplement modifier cette commande pour que
l'archivage sur fasse sur le serveur esclave. Nous avions:</p>
<pre><code>archive_command = 'test ! -f /mnt/serveur/archive/%f &amp;&amp; cp -i \
  %p /mnt/serveur/archive/%f &lt;/dev/null'
</code></pre>
<p>Nous le transformons en:</p>
<pre><code>archive_command = 'scp "%p" "serveuresclave:/mnt/serveur/archive/%f"'
</code></pre>
<p>Où <code>serveuresclave</code> est le nom ou l'adresse IP du serveur esclave.</p>
<p>Nous pourrions garder notre commande d'archivage en utilisant un système de
fichier réseau comme NFS pour monter le répertoire distant du serveur esclave
sur le <strong>/mnt/serveur/archive</strong> du maître.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              82/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Il faut aussi bien sur tester une commande scp avec le user postgres à
destination de cette machine (par exemple en recopiant une vieiile archive que
nous avions dans notre /mnt/serveur/archive dans le même répertoire sur l'autre
machine). Nous avons écris un commande scp où la connexion ssh se fait sans
spécifier d'utilisateur ou de mot de passe, ceci est possible en configurant
une clef ssh pour l'utilisateur postgres et en la déployant sur le serveur
distant.</p>
<pre><code>    &gt; sudo su – postgres
    &gt; ssh-keygen -t dsa
    # nous devrions obtenir une clef : /var/lib/postgresql/.ssh/id_rsa.pub
    # nous recopions cette clef sur le serveur esclave
    # (il faut le mot de passe root distant), c'est une commande sur
    # une seule ligne
    &gt; scp /var/lib/postgresql/.ssh/id_dsa.pub \
     root@esclave:/tmp/id_dsa_master.pub
</code></pre>
<p>Sur le serveur esclave il faut installer cette clef de le HOME de l'utilisateur
<code>postgres</code>, dans le fichier <code>.ssh/authorized_keys</code>. Nous aurions pu automatiser
cette étape en utilisant <code>ssh-copy-id</code> depuis le serveur esclave, mais il
faudrait que l'utilisateur postgres possède un mot de passe.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              83/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Sur le serveur esclave on passe donc root et on tape ces commandes:</p>
<pre><code>&gt; sudo su -
&gt; # on en profite pour vider le répertoire d'archivage du serveur esclave.
&gt; rm -rf /mnt/serveur/archive/
&gt; # on devient l'utilisateur postgres pour installer
&gt; #les autorisations ssh
&gt; chown postgres /tmp/id_dsa_master.pub
&gt; su – postgres
&gt; mkdir ~/.ssh
&gt; cat /tmp/id_dsa_master.pub &gt;&gt; ~/.ssh/authorized_keys
</code></pre>
<p>Sur le serveur maître on teste que le scp fonctionne:</p>
<pre><code>&gt; scp /mnt/serveur/archive/000000020000000000000050 \
 serveuresclave:/mnt/serveur/archive/
</code></pre>
<p>On peut alors relancer le serveur, l'archivage devrait se faire dans le dossier
<code>/mnt/serveur/archive</code> du serveur esclave (vous pouvez commencer à lancer le
script <code>populate_app.php</code>).</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              84/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>On en profite aussi pour relancer notre script de backup afin d'avoir une copie
 binaire de la base à donner à l'esclave comme point de départ.</p>
<pre><code>&gt; sudo ./backup.sh
# puis on recopie ce backup binaire sur l'esclave, quelque part
&gt; scp /mnt/serveur/backup/backup.tar \
  serveuresclave:/mnt/serveur/backup/
</code></pre>
<p>Sur l'esclave on modifie quelques éléments:</p>
<p>on utilise le backup binaire que l'on a reçu du maître pour initialiser le
contenu des fichiers physiques de la base</p>
<pre><code>cp /mnt/serveur/backup/backup.tar /backup.tar
[root@localhost ~]# cd /
[root@localhost /]# tar xfv backup.tar
</code></pre>
<p>Vérifiez que les deux serveurs sont <strong>à la même heure!</strong> Utilisez un protocole
comme <strong>ntp</strong> pour avoir des serveurs à l'heure.</p>
<p>On suspend l'archivage des WAL et on passe le <code>wal_level</code> à sa valeur par défaut.
Sur l'esclave on n'a pas besoin de générer une deuxième version des journaux de
transactions</p>
<pre><code>wal_level = minimal
archive_mode = off
</code></pre>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              85/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <div class="warning"><p>
<b>ATTENTION:</b> en recopiant le dossier physique venant du maître on a sans
doute recopié son <b>pg_hba.conf</b> et son fichier <b>postgresql.conf</b>.
Il faut donc bien modifier ces valeurs de configuration après la copie.
Un script pourrait utiliser du sed, ou recopier un fichier de configuration
sauvegardé sous un autre nom.
</p></div>

<p>Nous ne démarrons toujours pas le serveur sur l'esclave.
Au préalable il nous
faut <strong>lui donner un fichier recovery.conf</strong>, afin qu'il fonctionne comme un serveur
en mode restauration. Nous créons donc un fichier <code>recovery.conf</code> dans son
répertoire de données dans lequel nous indiquons une commande de restauration un
peu spéciale puisqu'elle utilise le programme <code>pg_standby</code>. (faites un
« locate pg_standby » pour trouver le votre, qui fait partie des programmes
contrib de postgreSQL).</p>
<pre><code># cette commande tient sur une ligne
restore_command = '/path/to/9.0/bin/pg_standby -d -t \
 /tmp/trigger_stanby_end /mnt/serveur/archive %f %p %r \
 &gt;&gt;/var/log/postgresql/pg_standby.log 2&gt;&amp;1'
</code></pre>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              86/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Nous pouvons voir que le programme va essayer de faire un log de ce qui lui
arrive dans <code>/var/log/postgresql/pg_standby.log</code>, on va donc initialiser ce
fichier et autoriser postgres à écrire dans ce fichier. On vérifiera aussi que
le DATADIR récupéré du maitre appartient bien à l'utilisateur postgres.</p>
<pre><code>&gt; chown -R postgres /path/to/postgresql/data/*
&gt; touch /var/log/postgresql/pg_standby.log
&gt; chown postgres /var/log/postgresql/pg_standby.log
</code></pre>
<p>Enfin on peut démarrer notre serveur esclave</p>
<pre><code>/etc/init.d/postgresql start
</code></pre>
<p>Celui-ci se lance en mode restauration.</p>
<p>Pour visualiser ce que le serveur est en train de faire vous pouvez lancer ces
commandes:</p>
<pre><code>ps auxf|grep postgres
tail -f /var/log/postgresql/pg_standby.log
</code></pre>
<p>Si la commande de popualtion de la base (<code>populate_app.php</code>) tourne sur le
master on pourra visualiser l'arrivée progressive des WAL sur l'esclave.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              87/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Par contre toute tentative d'accès direct à la base esclave est impossible.</p>
<pre><code>psql -Upostgres -d postgres -h localhost -p 5432
</code></pre>
<p>Par rapport à une restauration classique nous avons le programme <code>pg_standby</code>
qui est en fait en attente d'un fichier que nous lui avons indiqué dans la
commande. Tant que ce fichier « trigger file »  <code>/tmp/trigger_stanby_end</code>
 n'existe pas pg_standby force le serveur à rester en mode restauration (en
 attente de WAL), et donc le serveur est injoignable.</p>
<p>Arrêtons la réplication en créant ce fichier:</p>
<pre><code>touch /tmp/trigger_stanby_end
</code></pre>
<p>On obtient alors une base indépendant de la base maître. La création de ce
<strong>« fichier trigger »</strong> est donc plutôt à la charge d'un service comme
<strong>keepalived</strong> qui démarre le service sur l'esclave lors d'une bascule.</p>
<p>Repasser l'esclave en statut esclave demande de repartir d'un backup binaire du
maître.</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              88/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Une <strong>bascule retour (failback)</strong> devrait être prévue dans vos procédures, sans
doute à partir d'une sauvegarde de ce nouveau maître (peut-être alors
faudra-t-il activer l'archivage des WAL sur cet esclave afin d'effectuer un
backup binaire)</p>
<div class="warning"><p>
A noter: il existe des outils libres pour simplifier la mise en œuvre d'une
réplication <b>WARM STANDBY</b> : <b>walmgr</b> de Skype et <b>pitrtools</b> de
Command Prompt.
</p></div>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              89/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.11.3. HOT STANDBY</h3>
              
              
                <p>PostgreSQL 9 introduit une variation sur le <strong>Warm Standby</strong> qui est donc le
<strong>Hot Standby</strong>.</p>
<p>Dans ce mode la connexion au serveur esclave est possible et nous affiche le
contenu de la base en décalé (l'esclave ne dispose que des journaux transférés
– on parle de <strong>log shipping</strong>).</p>
<p>On peut réduire le décalage en jouant sur des paramètres <strong>archive_timeout</strong> de
l'ordre de quelques secondes sur le maître si les canal de transfert des
fichiers WAL est rapide entre le maître et l'esclave et que les scripts
d'archivage et de restauration font un nettoyage efficace des WAL qui ne sont
plus utiles.</p>
<p>On commence par arrêter le serveur esclave qui est sans doute devenu maître à
la fin de l'exercice précédent, et on supprime le fichier
<code>/tmp/trigger_stanby_end</code></p>
<p>On modifie le fichier <code>postgresql.conf</code> du maître pour passer à un niveau un
peu supérieur de WAL:</p>
<pre><code>wal_level = 'hot_standby'
</code></pre>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              90/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Puis comme dans le WARM STANDBY nous devons:</p>
<ul>
<li><strong>redémarrer</strong> le serveur maître</li>
<li>effectuer un <strong>backup binaire</strong></li>
<li><strong>transférer</strong> ce backup sur l'esclave.</li>
<li><strong>décompresser</strong> le backup sur l'esclave</li>
<li>s'assurer que tous les fichiers appartiennent bien à postgres</li>
</ul>
<p>Là nous allons modifier le fichier <code>postgresql.conf</code> de l'esclave qui doit
contenir le paramétrage du maître, pour lui indiquer le paramétrage de l'esclave
en hot_standby, en gras j'indique ce qui change par rapport au warm standby:</p>
<pre><code>wal_level = minimal
archive_mode = off
<b>hot_standby = on</b>
</code></pre>

<p>Ensuite nous devons remettre en place un fichier <code>recovery.conf</code>, identique à
celui du warm standby, contenant la <code>commande pg_stanby</code>. Puis :</p>
<pre><code>/etc/init.d/postgresql-9.6 start
</code></pre>
<p>Nous obtenons un serveur en lecture seule et en décalage léger avec le maître.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              91/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <div class="action"><p>
En utilisant populate_app.php sur le maître constatez les différences entre les
deux serveurs en effectuant des requête de <b>count(*)</b> sur
<b>app.commandes</b>.
</p></div>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              92/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.11.4. STREAMING REPLICATION</h3>
              
              
                <p>Pour obtenir un serveur de type <strong>hot standby</strong> avec une <strong>latence plus courte</strong>,
un temps plus court de répercution des WAL, on peut donc réduire
<strong>l'archive_timeout</strong>. Mais une meilleure solution existe.</p>
<p>La <strong>réplication par flux</strong> va ajouter aux <strong>Hot Standby</strong> un <strong>flux d'envoi
direct des transactions</strong> entre le maître et ses esclaves.</p>
<p>Au niveau du maître <strong>des processus wal_sender</strong> vont se charger d'envoyer des
informations en flux tendus à des <strong>processus wal_receiver</strong> situés au niveau
des esclaves.</p>
<p>Plusieurs nouveaux paramètres entrent en jeu:</p>
<ul>
<li><strong>max_wal_senders</strong> : nombre de processus chargés de la synchronisation au
  niveau du maître (un par esclave)</li>
<li><strong>wal_sender_delay</strong> : délai d'attente, par défaut à 200ms entre chaque
  « exécution » du cycle de synchronisation, la valeur doit être un multiple
  de 10ms</li>
<li><strong>wal_keep_segments</strong> : nombre de WAL qui peuvent être conservés dans
  <code>pg_xlog</code> pour la réplication par flux. Si l'esclave <strong>prends du retard</strong> et
  que les segments ne sont plus dans pg_xlog il devra attendre la récupération
  via l'archivage des WAL (comme en hot_standby ou warm standby classique).
  Le défaut à 0 signifie que le maître ne fais pas attention à conserver ou pas
  des WAL pour la réplication par flux, il gère ces WAL dans le pg_xlog comme
  d'habitude, en fonction des CHECKPOINT principalement.</li>
</ul>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              93/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Si l'esclave ne fonctionne qu'avec <strong>un</strong> wal_receiver et sans
<strong>restore_command</strong> capable de récupérer des WAL archivés il faut absolument
spécifier un nombre <strong>assez élevé</strong> dans wal_keep_segments afin d'éviter de
désynchroniser un esclave en cas de charge d'écriture importante qu'il n'aura
su effectuer dans les temps.</p>
<p>Cette réplication 'en flux tendu' va demander des connexions depuis l'esclave
vers le maître. Il faut donc que l'esclave utilise <strong>un compte utilisateur</strong>
(éventuellement avec un mot de passe) et que le maître autorise la connexion
avec cet utilisateur depuis l'adresse IP de l'esclave.</p>
<p>Il va donc nous falloir éditer le <code>pg_hba.conf du maître</code>. L'accès se fait sur
une base <em>'spéciale'</em> nommée <strong>replication</strong>. Nous ajoutons donc en fin de
fichier <strong>pg_hba.conf</strong> cette ligne (adaptez l'adresse IP à votre cas):</p>
<pre><code># TYPE  DATABASE        USER            CIDR-ADDRESS            METHOD
host    replication     ultrogothe        192.168.1.13/24            trust
</code></pre>
<p>On ajoute ensuite le 1er processus d'envoi des WAL en flux dans le
<strong>postgresql.conf</strong> du maître (qui est déjà configuré pour du hot_standby):</p>
<pre><code>max_wal_sender = 1
</code></pre>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              94/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Faites un restart du serveur PostgreSQl du maître</p>
<pre><code>/etc/init.d/postgresql-9.6 restart
</code></pre>
<p>Si nous regardons du côté du serveur esclave nous avons toujours notre esclave
en <strong>HOT STANDBY</strong>, avec un <strong>recovery.conf actif</strong>. Nous allons devoir
l'adapter au niveau de son <strong>recovery.conf</strong> pour qu'il se mette <strong>en écoute du
flux de transactions du maître</strong>.</p>
<p>Nous allons le configurer pour la réplication de flux en indiquant quelques
paramètres supplémentaires dans ce fichier, dont le principal est <strong>standby_mode</strong>.</p>
<p>A partir du moment où nous entrons dans ce mode l'utilitaire <strong>pg_standby</strong> que
nous utilisions pour le <strong>HOT STANDBY</strong> n'est <strong>plus utile</strong> (on a de nouvelles
options de configurations pour le trigger file par exemple) et la commande de
restauration se simplifie pour n'être plus qu'une simple copie des fichiers
d'archive:</p>
<p>On modifie donc le <strong>recovery.conf</strong> (pas le *<em>postgresql.conf</em>) de cette façon
(ici 192.168.1.10 est l'IP du maître):</p>
<pre><code>standby_mode = 'on'
restore_command = 'cp /mnt/serveur/archive/%f %p'
primary_conninfo = 'host=192.168.1.10 port=5432 user=ultrogothe'
trigger_file = '/tmp/trigger_stanby_end'
</code></pre>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              95/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>Il faut un user superutilisateur de la base. Vérifiez que l'utilisateur possède
ce droit. Ici nous indiquons trust en nous filtrons sur l'adresse IP plus le
masque de sous-réseau de l'esclave. Vous pourriez utiliser md5 pour forcer la
vérification du mot de passe.</p>
<p>Consultez les logs de l'esclave pour d'éventuels problèmes de connexion et pour
observer la réplication (faires un grep replication sur les fichiers de log).</p>
<div class="action"><p>
Faites tourner populate_app.php et faites des requêtes de comptage sur le maître
 et l'esclave, observez la réplication qui semble instantanée.
</p></div>

<p>Cela nous permet de faire un premier aperçu de la réplication par PostgreSQL.</p>
<p>Nous obtenons une réplication maître esclave quasi-synchrone. Le risque étant un
décalage sur le serveur esclave à cause de requêtes en lecture longues qui
posent des locks sur des opérations d'écritures importantes. Une fois encore
je citerai <a href="http://www.dalibo.org/glmf131_mise_en_place_replication_postgresl_9.0_2">l'article de Guillaume Lelarge</a>
Vous trouverez dans cet article des réglages assez fins des problématiques de
<strong>lock de lecture</strong> (sic) et des principes de bascules <strong>(switchover, failover,
 failback)</strong>.</p>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              96/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide title2">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h2>20.12. Autres systèmes de réplication</h2>
              
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              97/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide wide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <p>D'autres système de réplication existent autour de PostgreSQL. Certains sont
utilisées depuis très longtemps. On citera les principaux:</p>
<ul>
<li><strong>SLONY</strong> : <strong>réplication par les triggers</strong>. Historiquement Slony était le
 principal outil de réplication pour les solutions Web sur lesquelles on voulait
disposer d'un esclave accessible en lecture et synchrone avec les modifications
de la base. Slony impose de ne pas modifier le schéma de la base et de disposer
d'une liste des tables et des clefs primaires de chaque table.
Slony se charge ensuite, base par base, table par table, de répercuter les
modifications quand elles arrivent sur les esclaves (un serveur peut être maître
d'une base ou d'une partie des tables de la base, et esclaves sur d'autres bases
et/ou tables)</li>
<li><strong>Pgpool II</strong> : <strong>réplication des requêtes</strong>. Pgpool est un <strong>pooler de
 connexions</strong>, une des fonctionnalités offertes par un pooler est de répercuter
 sur tous les serveurs d'une grappe l'ensemble des requêtes effectuant des
 opérations en écriture. Si toutes les connexions passent bien par le pooler et
 que les requêtes ne font pas appel à des valeurs aléatoires on obtient des
 bases identiques.</li>
<li><strong>Londiste</strong> : <strong>réplication par les triggers</strong>. Utilitaire de réplication de
 Skype. Sa configuration est plus simple que celle de SLONY, par contre sa
 documentation est encore plus succinte que celle de SLONY, qui n'est déjà pas
 un modèle du genre.</li>
</ul>

              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              98/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
              
                <ul>
<li><strong>Bucardo</strong>: réplication <strong>master-master</strong> : le système le plus <strong>complexe</strong>
  et le <strong>plus avancé</strong>, vous obtenez un cluster de serveurs PostgreSQL dans
  lequel vous pouvez effectuer vos écritures sur n'importe quel serveur</li>
<li><strong>DRBD</strong> : DRBD est une solution de <strong>réplication des disques entre serveurs</strong>,
  il ne s'agit donc pas d'une réplication de base de donnée. Les deux serveurs,
  le maître et l'esclave, partagent <strong>un même disque dur</strong>. Toutes les écritures
  effectuées sur le disque du maître sont répliquées sur le disque de l'esclave.
  On utilise le plus souvent DRBD pour faire des bascules d'urgence, l'esclave
  peut à tout moment reprendre la main sur le maître avec une bascule de type
  <strong>keepalived</strong>, il devient le maître de DRBD et peut alors lancer sa propre
  version de la base qui disposera des mêmes fichiers physiques (un partage
  DRBD devrait <strong>inclure le partage du pg_xlog</strong> pour éviter d'avoir à faire une
  restauration). Certains système des fichiers avancés comme <strong>OCFS-2</strong> peuvent
  supporter des écritures concurrentes sur le partage DRBD, mais il serait
  dangereux d'utiliser DRBD dans ce sens avec des systèmes de base de données.</li>
</ul>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              99/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide title2">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h2>20.13. Autres outils</h2>
              
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              100/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.13.1. Monitorer PostgreSQL</h3>
              
              
                <ul>
<li><a href="http://bucardo.org/wiki/Check_postgres">http://bucardo.org/wiki/Check_postgres</a></li>
</ul>
<p>Pour intégrer la supervsion de PostgreSQL dans vos solutions de monitoring le
principal outil sera la sonde <strong>Nagios</strong> <strong>check_postgres</strong>, sonde écrite en
<strong>Perl</strong> (mais très orientée Linux). Cette sonde est maintenue par <strong>Bucardo</strong>,
un des acteurs majeurs du monde PostgreSQL. L'ensemble des vérifications pouvant
être effectuées est assez important. Vous devrez créer plusieurs services Nagios
utilisant cette sonde de différentes manière. Ces différentes vérifications sont
les Actions de la sonde dont vous pouvez <a href="http://bucardo.org/check_postgres/check_postgres.pl.html">voir la liste sur cette page</a>.</p>
<p>En terme de <strong>supervision passive (graphiques)</strong> on pourra consulter ces liens:</p>
<ul>
<li><a href="http://wiki.postgresql.org/wiki/Cacti">http://wiki.postgresql.org/wiki/Cacti</a> (Cacti)</li>
<li><a href="http://munin-monitoring.org/wiki/PluginCat">http://munin-monitoring.org/wiki/PluginCat</a> (Munin)</li>
<li><a href="http://muninpgplugins.projects.postgresql.org/">http://muninpgplugins.projects.postgresql.org/</a> (Munin)</li>
<li><a href="http://tigreraye.org/Modules%20PostgreSQL%20pour%20Munin">http://tigreraye.org/Modules%20PostgreSQL%20pour%20Munin</a> (Munin)</li>
</ul>
<p>On trouvera beaucoup plus de ressources, et d'un meilleur niveau, pour Munin que
pour Cacti.</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              101/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.13.2. PgAgent</h3>
              
              
                <ul>
<li><a href="https://www.pgadmin.org/docs/pgadmin3/1.22/pgagent.html">https://www.pgadmin.org/docs/pgadmin3/1.22/pgagent.html</a></li>
</ul>
<p><strong>PgAgent</strong> est un programme complémentaire de <strong>pgAdmin</strong> qui permet la mise en
place de <strong>scripts de maintenance récurrents</strong>. On peut l'utiliser pour
planifier des scripts SQL de traitements batchs, ou pour simplement faire des
appels à des procédures stockées de batchs. PgAgent peut aussi lancer des
scripts systèmes et découper ses « jobs » en plusieurs étapes (steps).</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              102/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.13.3. PgPool II</h3>
              
              
                <ul>
<li><a href="http://pgpool.projects.postgresql.org/">http://pgpool.projects.postgresql.org/</a></li>
<li><a href="http://pgpool.projects.postgresql.org/pgpool-II/doc/pgpool-fr.html">http://pgpool.projects.postgresql.org/pgpool-II/doc/pgpool-fr.html</a></li>
</ul>
<p><strong>pgpool II</strong> est un <strong>pooler de connexions</strong>.</p>
<p>Un des apports important d'un pooler de connexion est de pouvoir mettre en
attente les demandes de connexions supplémentaires plutôt que de les rejeter.
Vous obtiendrez, en cas d'un nombre de connexions trop élevé, des lenteurs
d'accès (plus ou moins longue suivant le dépassement), mais aucun message
d'erreur. Il y a un effet de <strong>lissage</strong>.</p>
<p>L'autre apport utile consiste à utiliser le pooler pour de la <strong>répartition de
charge</strong> sur un ensemble de serveurs. Si vous disposez d'esclaves en lecture
seule avec des données synchrones, le pooler pourra répartir la charge des
requêtes <strong>hors-transaction</strong> sur ces serveurs (les select au sein de
transactions devant bien sur rester sur le serveur de la transaction).</p>
<p>Enfin l'apport premier d'un pooler est de maintenir des connexions ouvertes sur
le serveur pour éviter les latences dues au <strong>temps d'établissement de ces
connexions</strong>.</p>
<p>Mais si vous lisez en détail la documentation de pgpool II vous découvrirez
certainement de nombreuses autres applications utiles (réplication des requêtes,
parallélisation de traitement, bascules failover, etc).</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              103/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.13.4. PgSnap!</h3>
              
              
                <ul>
<li><a href="http://pgsnap.projects.postgresql.org/">http://pgsnap.projects.postgresql.org/</a></li>
<li><a href="http://pgsnap.projects.postgresql.org/pagila2_snap_20111029/">http://pgsnap.projects.postgresql.org/pagila2_snap_20111029/</a> (démo)</li>
</ul>
<p>PGSnap! Est un programme PHP qui <strong>génère un rapport sur l'état de la base</strong>.</p>
<p>Je devrais plutôt dire qu'il génère un ensemble de rapports. Il s'agit d'un bon
outil complémentaire de la supervision et qui permettra à un DBA d'avoir une
vision de ses serveurs à la fois synthétique et détaillée pour les éventuels
problèmes.</p>
<p>Parcourez la démonstration pour découvrir les différents rapports. Remarquez la
possibilité de demander les requêtes effectuées sur le catalogue pour pouvoir
les réutiliser de votre côté en les adaptant.</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              104/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.13.5. pgbadger</h3>
              
              
                <ul>
<li><a href="http://dalibo.github.io/pgbadger/">http://dalibo.github.io/pgbadger/</a></li>
<li><a href="https://github.com/dalibo/pgbadger">https://github.com/dalibo/pgbadger</a></li>
<li><a href="https://github.com/dalibo/pgbadger">démo</a></li>
</ul>
<p>Si vous trouvez PgSnap sympa et intéressant, <strong>pgBadger</strong> est en fait là pour
faire <strong>la même chose en mieux</strong>.</p>
<p>Il s'agit d'un analyseur de logs, qui va générer un rapport très complet et très
graphique sur de nombreux éléments (requêtes gourmandes, répartition du traffic
par type de requêtes, ar application, stats internes, vacuums, etc)</p>
<p>Comme pour beaucoup d'analyseurs de logs, avec une base qui génère des logs
quotidiens volumineux il faudra tester un fonctionnement.</p>
<p>Par exemple mettre en place la génération du rapport chaque jour, et la rotation
de logs de requêtes sur une journée max, retirer une partie des logs et donc
du rapport, etc.</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              105/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.13.6. pgfouine</h3>
              
              
                <ul>
<li><a href="http://pgfouine.projects.postgresql.org/">http://pgfouine.projects.postgresql.org/</a>
pgFouine est un programme PHP, c'est un analyseur de logs.</li>
</ul>
<p>Examinez les démonstrations de rapports générés par pgFouine sur cette page http://pgfouine.projects.postgresql.org/reports.html</p>
<p>Comme pgSnap c'est un outil qui est sans doute dépassé par bdPadger, mais que
l'on trouve encore pour raisons historiques.</p>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              106/107
            </aside>
          </footer>
        </div>
      </div>
      
      <!-- slide source: src/SupportCoursPostgreSQL4.md -->
      <div class="slide-wrapper">
        <div class="slide">
          <div class="inner-wrapper">
            <div class="inner">
              
                <h3>20.13.7. d'autres?</h3>
              
              
                <ul>
<li><a href="https://wiki.postgresql.org/wiki/Performance_Analysis_Tools">https://wiki.postgresql.org/wiki/Performance_Analysis_Tools</a></li>
<li><a href="https://wiki.postgresql.org/wiki/Monitoring">https://wiki.postgresql.org/wiki/Monitoring</a></li>
</ul>
              
            </div>
          </div>

          <div class="presenter_notes">
            <header>Notes</header>
            <section>
              
            </section>
          </div>

          <footer>
            
            <img src="assets/makina/logo.png" class="logo" alt="Makina Corpus"/>
            

            
            <aside class="source">
              Source: <a href="src/SupportCoursPostgreSQL4.md">src/SupportCoursPostgreSQL4.md</a>
            </aside>
            

            <aside class="page_number">
              107/107
            </aside>
          </footer>
        </div>
      </div>
      
    </div>
  </div>

  
  <div id="toc" class="sidebar hidden">
    <h2>Table of Contents</h2>
    <table>
      <caption>Table of Contents</caption>
      
      <tr id="toc-row-1">
        <th><a href="#slide1">Formation Pratique PostgreSQL - partie 4 - Administration</a></th>
        <td><a href="#slide1">1</a></td>
      </tr>
      
      
      <tr id="toc-row-2">
        <th><a href="#slide2">-</a></th>
        <td><a href="#slide2">2</a></td>
      </tr>
      
      
      <tr id="toc-row-3">
        <th><a href="#slide3">20. Administration PostgreSQL</a></th>
        <td><a href="#slide3">3</a></td>
      </tr>
      
        
        <tr id="toc-row-4" class="sub">
          <th><a href="#slide4">20.1. Pré-requis</a></th>
          <td><a href="#slide4">4</a></td>
        </tr>
        
      
      
      <tr id="toc-row-5">
        <th><a href="#slide5">-</a></th>
        <td><a href="#slide5">5</a></td>
      </tr>
      
        
        <tr id="toc-row-6" class="sub">
          <th><a href="#slide6">20.2. 32bits vs 64bits</a></th>
          <td><a href="#slide6">6</a></td>
        </tr>
        
        <tr id="toc-row-7" class="sub">
          <th><a href="#slide7">20.3. Analysez l'usage de la base</a></th>
          <td><a href="#slide7">7</a></td>
        </tr>
        
        <tr id="toc-row-8" class="sub">
          <th><a href="#slide8">20.4. Autovacuum, vacuum et analyze</a></th>
          <td><a href="#slide8">8</a></td>
        </tr>
        
      
      
      <tr id="toc-row-9">
        <th><a href="#slide9">-</a></th>
        <td><a href="#slide9">9</a></td>
      </tr>
      
      
      <tr id="toc-row-10">
        <th><a href="#slide10">-</a></th>
        <td><a href="#slide10">10</a></td>
      </tr>
      
      
      <tr id="toc-row-11">
        <th><a href="#slide11">-</a></th>
        <td><a href="#slide11">11</a></td>
      </tr>
      
      
      <tr id="toc-row-12">
        <th><a href="#slide12">-</a></th>
        <td><a href="#slide12">12</a></td>
      </tr>
      
      
      <tr id="toc-row-13">
        <th><a href="#slide13">-</a></th>
        <td><a href="#slide13">13</a></td>
      </tr>
      
      
      <tr id="toc-row-14">
        <th><a href="#slide14">-</a></th>
        <td><a href="#slide14">14</a></td>
      </tr>
      
      
      <tr id="toc-row-15">
        <th><a href="#slide15">-</a></th>
        <td><a href="#slide15">15</a></td>
      </tr>
      
      
      <tr id="toc-row-16">
        <th><a href="#slide16">-</a></th>
        <td><a href="#slide16">16</a></td>
      </tr>
      
        
        <tr id="toc-row-17" class="sub">
          <th><a href="#slide17">20.5. Paramètres de configuration principaux</a></th>
          <td><a href="#slide17">17</a></td>
        </tr>
        
      
      
      <tr id="toc-row-18">
        <th><a href="#slide18">-</a></th>
        <td><a href="#slide18">18</a></td>
      </tr>
      
      
      <tr id="toc-row-19">
        <th><a href="#slide19">-</a></th>
        <td><a href="#slide19">19</a></td>
      </tr>
      
      
      <tr id="toc-row-20">
        <th><a href="#slide20">-</a></th>
        <td><a href="#slide20">20</a></td>
      </tr>
      
      
      <tr id="toc-row-21">
        <th><a href="#slide21">-</a></th>
        <td><a href="#slide21">21</a></td>
      </tr>
      
      
      <tr id="toc-row-22">
        <th><a href="#slide22">-</a></th>
        <td><a href="#slide22">22</a></td>
      </tr>
      
      
      <tr id="toc-row-23">
        <th><a href="#slide23">-</a></th>
        <td><a href="#slide23">23</a></td>
      </tr>
      
      
      <tr id="toc-row-24">
        <th><a href="#slide24">-</a></th>
        <td><a href="#slide24">24</a></td>
      </tr>
      
      
      <tr id="toc-row-25">
        <th><a href="#slide25">-</a></th>
        <td><a href="#slide25">25</a></td>
      </tr>
      
      
      <tr id="toc-row-26">
        <th><a href="#slide26">-</a></th>
        <td><a href="#slide26">26</a></td>
      </tr>
      
      
      <tr id="toc-row-27">
        <th><a href="#slide27">-</a></th>
        <td><a href="#slide27">27</a></td>
      </tr>
      
      
      <tr id="toc-row-28">
        <th><a href="#slide28">-</a></th>
        <td><a href="#slide28">28</a></td>
      </tr>
      
      
      <tr id="toc-row-29">
        <th><a href="#slide29">-</a></th>
        <td><a href="#slide29">29</a></td>
      </tr>
      
      
      <tr id="toc-row-30">
        <th><a href="#slide30">-</a></th>
        <td><a href="#slide30">30</a></td>
      </tr>
      
      
      <tr id="toc-row-31">
        <th><a href="#slide31">-</a></th>
        <td><a href="#slide31">31</a></td>
      </tr>
      
      
      <tr id="toc-row-32">
        <th><a href="#slide32">-</a></th>
        <td><a href="#slide32">32</a></td>
      </tr>
      
      
      <tr id="toc-row-33">
        <th><a href="#slide33">-</a></th>
        <td><a href="#slide33">33</a></td>
      </tr>
      
        
        <tr id="toc-row-34" class="sub">
          <th><a href="#slide34">20.6. Considérations matérielles pour la performance</a></th>
          <td><a href="#slide34">34</a></td>
        </tr>
        
      
      
      <tr id="toc-row-35">
        <th><a href="#slide35">-</a></th>
        <td><a href="#slide35">35</a></td>
      </tr>
      
      
      <tr id="toc-row-36">
        <th><a href="#slide36">-</a></th>
        <td><a href="#slide36">36</a></td>
      </tr>
      
        
        <tr id="toc-row-37" class="sub">
          <th><a href="#slide37">20.7. Backup et Restaurations liés à l'archivage WAL</a></th>
          <td><a href="#slide37">37</a></td>
        </tr>
        
      
      
      <tr id="toc-row-38">
        <th><a href="#slide38">-</a></th>
        <td><a href="#slide38">38</a></td>
      </tr>
      
      
      <tr id="toc-row-39">
        <th><a href="#slide39">-</a></th>
        <td><a href="#slide39">39</a></td>
      </tr>
      
      
      <tr id="toc-row-40">
        <th><a href="#slide40">-</a></th>
        <td><a href="#slide40">40</a></td>
      </tr>
      
      
      <tr id="toc-row-41">
        <th><a href="#slide41">-</a></th>
        <td><a href="#slide41">41</a></td>
      </tr>
      
      
      <tr id="toc-row-42">
        <th><a href="#slide42">-</a></th>
        <td><a href="#slide42">42</a></td>
      </tr>
      
      
      <tr id="toc-row-43">
        <th><a href="#slide43">-</a></th>
        <td><a href="#slide43">43</a></td>
      </tr>
      
      
      <tr id="toc-row-44">
        <th><a href="#slide44">-</a></th>
        <td><a href="#slide44">44</a></td>
      </tr>
      
      
      <tr id="toc-row-45">
        <th><a href="#slide45">-</a></th>
        <td><a href="#slide45">45</a></td>
      </tr>
      
      
      <tr id="toc-row-46">
        <th><a href="#slide46">-</a></th>
        <td><a href="#slide46">46</a></td>
      </tr>
      
      
      <tr id="toc-row-47">
        <th><a href="#slide47">-</a></th>
        <td><a href="#slide47">47</a></td>
      </tr>
      
      
      <tr id="toc-row-48">
        <th><a href="#slide48">-</a></th>
        <td><a href="#slide48">48</a></td>
      </tr>
      
      
      <tr id="toc-row-49">
        <th><a href="#slide49">-</a></th>
        <td><a href="#slide49">49</a></td>
      </tr>
      
      
      <tr id="toc-row-50">
        <th><a href="#slide50">-</a></th>
        <td><a href="#slide50">50</a></td>
      </tr>
      
      
      <tr id="toc-row-51">
        <th><a href="#slide51">-</a></th>
        <td><a href="#slide51">51</a></td>
      </tr>
      
      
      <tr id="toc-row-52">
        <th><a href="#slide52">-</a></th>
        <td><a href="#slide52">52</a></td>
      </tr>
      
      
      <tr id="toc-row-53">
        <th><a href="#slide53">-</a></th>
        <td><a href="#slide53">53</a></td>
      </tr>
      
      
      <tr id="toc-row-54">
        <th><a href="#slide54">-</a></th>
        <td><a href="#slide54">54</a></td>
      </tr>
      
      
      <tr id="toc-row-55">
        <th><a href="#slide55">-</a></th>
        <td><a href="#slide55">55</a></td>
      </tr>
      
      
      <tr id="toc-row-56">
        <th><a href="#slide56">-</a></th>
        <td><a href="#slide56">56</a></td>
      </tr>
      
      
      <tr id="toc-row-57">
        <th><a href="#slide57">-</a></th>
        <td><a href="#slide57">57</a></td>
      </tr>
      
      
      <tr id="toc-row-58">
        <th><a href="#slide58">-</a></th>
        <td><a href="#slide58">58</a></td>
      </tr>
      
      
      <tr id="toc-row-59">
        <th><a href="#slide59">-</a></th>
        <td><a href="#slide59">59</a></td>
      </tr>
      
      
      <tr id="toc-row-60">
        <th><a href="#slide60">-</a></th>
        <td><a href="#slide60">60</a></td>
      </tr>
      
        
        <tr id="toc-row-61" class="sub">
          <th><a href="#slide61">20.8. Tests de restauration de dump</a></th>
          <td><a href="#slide61">61</a></td>
        </tr>
        
      
      
      <tr id="toc-row-62">
        <th><a href="#slide62">-</a></th>
        <td><a href="#slide62">62</a></td>
      </tr>
      
      
      <tr id="toc-row-63">
        <th><a href="#slide63">-</a></th>
        <td><a href="#slide63">63</a></td>
      </tr>
      
      
      <tr id="toc-row-64">
        <th><a href="#slide64">-</a></th>
        <td><a href="#slide64">64</a></td>
      </tr>
      
        
        <tr id="toc-row-65" class="sub">
          <th><a href="#slide65">20.9. Intégrité des données</a></th>
          <td><a href="#slide65">65</a></td>
        </tr>
        
      
      
      <tr id="toc-row-66">
        <th><a href="#slide66">-</a></th>
        <td><a href="#slide66">66</a></td>
      </tr>
      
        
        <tr id="toc-row-67" class="sub">
          <th><a href="#slide67">20.10. Exemple de Politique de backups</a></th>
          <td><a href="#slide67">67</a></td>
        </tr>
        
      
      
      <tr id="toc-row-68">
        <th><a href="#slide68">-</a></th>
        <td><a href="#slide68">68</a></td>
      </tr>
      
      
      <tr id="toc-row-69">
        <th><a href="#slide69">-</a></th>
        <td><a href="#slide69">69</a></td>
      </tr>
      
      
      <tr id="toc-row-70">
        <th><a href="#slide70">-</a></th>
        <td><a href="#slide70">70</a></td>
      </tr>
      
      
      <tr id="toc-row-71">
        <th><a href="#slide71">-</a></th>
        <td><a href="#slide71">71</a></td>
      </tr>
      
      
      <tr id="toc-row-72">
        <th><a href="#slide72">-</a></th>
        <td><a href="#slide72">72</a></td>
      </tr>
      
      
      <tr id="toc-row-73">
        <th><a href="#slide73">-</a></th>
        <td><a href="#slide73">73</a></td>
      </tr>
      
      
      <tr id="toc-row-74">
        <th><a href="#slide74">-</a></th>
        <td><a href="#slide74">74</a></td>
      </tr>
      
      
      <tr id="toc-row-75">
        <th><a href="#slide75">-</a></th>
        <td><a href="#slide75">75</a></td>
      </tr>
      
      
      <tr id="toc-row-76">
        <th><a href="#slide76">-</a></th>
        <td><a href="#slide76">76</a></td>
      </tr>
      
      
      <tr id="toc-row-77">
        <th><a href="#slide77">-</a></th>
        <td><a href="#slide77">77</a></td>
      </tr>
      
        
        <tr id="toc-row-78" class="sub">
          <th><a href="#slide78">20.11. Utiliser les WAL pour la réplication</a></th>
          <td><a href="#slide78">78</a></td>
        </tr>
        
      
      
      <tr id="toc-row-79">
        <th><a href="#slide79">-</a></th>
        <td><a href="#slide79">79</a></td>
      </tr>
      
      
      <tr id="toc-row-80">
        <th><a href="#slide80">-</a></th>
        <td><a href="#slide80">80</a></td>
      </tr>
      
      
      <tr id="toc-row-81">
        <th><a href="#slide81">-</a></th>
        <td><a href="#slide81">81</a></td>
      </tr>
      
      
      <tr id="toc-row-82">
        <th><a href="#slide82">-</a></th>
        <td><a href="#slide82">82</a></td>
      </tr>
      
      
      <tr id="toc-row-83">
        <th><a href="#slide83">-</a></th>
        <td><a href="#slide83">83</a></td>
      </tr>
      
      
      <tr id="toc-row-84">
        <th><a href="#slide84">-</a></th>
        <td><a href="#slide84">84</a></td>
      </tr>
      
      
      <tr id="toc-row-85">
        <th><a href="#slide85">-</a></th>
        <td><a href="#slide85">85</a></td>
      </tr>
      
      
      <tr id="toc-row-86">
        <th><a href="#slide86">-</a></th>
        <td><a href="#slide86">86</a></td>
      </tr>
      
      
      <tr id="toc-row-87">
        <th><a href="#slide87">-</a></th>
        <td><a href="#slide87">87</a></td>
      </tr>
      
      
      <tr id="toc-row-88">
        <th><a href="#slide88">-</a></th>
        <td><a href="#slide88">88</a></td>
      </tr>
      
      
      <tr id="toc-row-89">
        <th><a href="#slide89">-</a></th>
        <td><a href="#slide89">89</a></td>
      </tr>
      
      
      <tr id="toc-row-90">
        <th><a href="#slide90">-</a></th>
        <td><a href="#slide90">90</a></td>
      </tr>
      
      
      <tr id="toc-row-91">
        <th><a href="#slide91">-</a></th>
        <td><a href="#slide91">91</a></td>
      </tr>
      
      
      <tr id="toc-row-92">
        <th><a href="#slide92">-</a></th>
        <td><a href="#slide92">92</a></td>
      </tr>
      
      
      <tr id="toc-row-93">
        <th><a href="#slide93">-</a></th>
        <td><a href="#slide93">93</a></td>
      </tr>
      
      
      <tr id="toc-row-94">
        <th><a href="#slide94">-</a></th>
        <td><a href="#slide94">94</a></td>
      </tr>
      
      
      <tr id="toc-row-95">
        <th><a href="#slide95">-</a></th>
        <td><a href="#slide95">95</a></td>
      </tr>
      
      
      <tr id="toc-row-96">
        <th><a href="#slide96">-</a></th>
        <td><a href="#slide96">96</a></td>
      </tr>
      
        
        <tr id="toc-row-97" class="sub">
          <th><a href="#slide97">20.12. Autres systèmes de réplication</a></th>
          <td><a href="#slide97">97</a></td>
        </tr>
        
      
      
      <tr id="toc-row-98">
        <th><a href="#slide98">-</a></th>
        <td><a href="#slide98">98</a></td>
      </tr>
      
      
      <tr id="toc-row-99">
        <th><a href="#slide99">-</a></th>
        <td><a href="#slide99">99</a></td>
      </tr>
      
        
        <tr id="toc-row-100" class="sub">
          <th><a href="#slide100">20.13. Autres outils</a></th>
          <td><a href="#slide100">100</a></td>
        </tr>
        
      
      
      <tr id="toc-row-101">
        <th><a href="#slide101">-</a></th>
        <td><a href="#slide101">101</a></td>
      </tr>
      
      
      <tr id="toc-row-102">
        <th><a href="#slide102">-</a></th>
        <td><a href="#slide102">102</a></td>
      </tr>
      
      
      <tr id="toc-row-103">
        <th><a href="#slide103">-</a></th>
        <td><a href="#slide103">103</a></td>
      </tr>
      
      
      <tr id="toc-row-104">
        <th><a href="#slide104">-</a></th>
        <td><a href="#slide104">104</a></td>
      </tr>
      
      
      <tr id="toc-row-105">
        <th><a href="#slide105">-</a></th>
        <td><a href="#slide105">105</a></td>
      </tr>
      
      
      <tr id="toc-row-106">
        <th><a href="#slide106">-</a></th>
        <td><a href="#slide106">106</a></td>
      </tr>
      
      
      <tr id="toc-row-107">
        <th><a href="#slide107">-</a></th>
        <td><a href="#slide107">107</a></td>
      </tr>
      
      
    </table>
  </div>
  

  <div id="help" class="sidebar hidden">
    <h2>Help</h2>
    <table>
      <caption>Help</caption>
      <tr>
        <th>Table of contents</th>
        <td>t</td>
      </tr>
      <tr>
        <th>Exposé</th>
        <td>ESC</td>
      </tr>
      <tr>
        <th>Autoscale</th>
        <td>e</td>
      </tr>
      <tr>
        <th>Full screen slides</th>
        <td>f</td>
      </tr>
      <tr>
        <th>Presenter view</th>
        <td>p</td>
      </tr>
      <tr>
        <th>Source files</th>
        <td>s</td>
      </tr>
      <tr>
        <th>Slide numbers</th>
        <td>n</td>
      </tr>
      <tr>
        <th>Blank screen</th>
        <td>b</td>
      </tr>
      <tr>
        <th>Notes</th>
        <td>2</td>
      </tr>
      <tr>
        <th>Help</th>
        <td>h</td>
      </tr>
    </table>
  </div>
  <script>$().landslide();</script>
</body>
</html>